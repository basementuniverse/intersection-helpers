// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@basementuniverse/vec

declare module '@basementuniverse/intersection-helpers' {
  export * as intersection2d from '@basementuniverse/intersection-helpers/src/2d';
  export * as intersection3d from '@basementuniverse/intersection-helpers/src/3d';
  export * as intersectionUtilities from '@basementuniverse/intersection-helpers/src/utilities';
}

declare module '@basementuniverse/intersection-helpers/src/2d' {
  import { vec2 } from '@basementuniverse/vec';
  import { AABB, Circle, Line, Point, Polygon, Ray, Rectangle } from '@basementuniverse/intersection-helpers/src/2d/types';
  export * from '@basementuniverse/intersection-helpers/src/2d/types';
  /**
    * Calculate the distance between two points
    */
  export function distance(a: Point, b: Point): number;
  /**
    * Calculate the clockwise angle from point a to point b
    *
    * The result is in radians and ranges from 0 to 2Ï€ (360 degrees)
    *
    * Returns 0 if the vectors are equal
    */
  export function angle(a: Point, b: Point): number;
  /**
    * Calculate the clockwise angle between two lines or rays
    *
    * Returns 0 if either line is zero-length
    */
  export function angleBetween(a: Line | Ray, b: Line | Ray): number;
  /**
    * Check if three points in 2D space are collinear
    */
  export function pointsAreCollinear(a: Point, b: Point, c: Point): boolean;
  /**
    * Convert a line segment to a ray
    */
  export function lineToRay(line: Line): Ray;
  /**
    * Convert a ray to a line segment
    */
  export function rayToLine(ray: Ray, length?: number): Line;
  /**
    * Get the bounding box (AABB) of a geometric object
    */
  export function aabb(o: Line | Rectangle | Circle | Polygon): AABB | null;
  /**
    * Convert an AABB to a rectangle
    */
  export function aabbToRectangle(aabb: AABB): Rectangle;
  /**
    * Check if two AABBs overlap and return the overlapping area if so
    */
  export function aabbsOverlap(a: AABB, b: AABB): {
      /**
        * Whether the two AABBs overlap
        */
      intersects: boolean;
      /**
        * The overlapping area, if the AABBs overlap
        */
      overlap?: AABB;
  };
  /**
    * Check if a point is inside an AABB
    *
    * This should be faster than pointInRectangle since we don't need to consider
    * rotation
    */
  export function pointInAABB(point: Point, aabb: AABB): {
      /**
        * Whether the point is inside the AABB
        */
      intersects: boolean;
      /**
        * The closest point on the AABB perimeter to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the AABB
        *
        * If the point is inside the AABB, this will be negative
        */
      distance: number;
  };
  /**
    * Check if a rectangle is rotated
    */
  export function rectangleIsRotated(rectangle: Rectangle): boolean;
  /**
    * Get the vertices of a rectangle
    *
    * Vertices will be returned in clockwise order starting at the top-left:
    * - Top-left
    * - Top-right
    * - Bottom-right
    * - Bottom-left
    */
  export function rectangleVertices(rectangle: Rectangle): Point[];
  /**
    * Convert a list of vertices to a list of edges
    */
  export function verticesToEdges(vertices: Point[]): Line[];
  /**
    * Check if a polygon is convex
    *
    * Returns null if the polygon is invalid
    */
  export function polygonIsConvex(polygon: Polygon): boolean | null;
  /**
    * Check if a polygon self-intersects
    */
  export function polygonSelfIntersects(polygon: Polygon): boolean;
  /**
    * Check if a polygon is valid
    *
    * A polygon is valid if it has at least 3 vertices and does not
    * self-intersect
    */
  export function polygonIsValid(polygon: Polygon): boolean;
  /**
    * Determine the winding order of a polygon's vertices
    *
    * Returns 'clockwise' or 'counter-clockwise' depending on the chosen
    * coordinate system
    *
    * By default we use the 'screen' coordinate system (y increases downwards)
    *
    * Returns null if the polygon is invalid
    */
  export function polygonWindingOrder(polygon: Polygon, options?: {
      /**
        * The coordinate system can be 'cartesian' (where y increases upwards) or
        * 'screen' (where y increases downwards, this is the default)
        */
      coordinateSystem?: 'cartesian' | 'screen';
  }): 'clockwise' | 'counter-clockwise' | null;
  /**
    * Calculate the area of a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function polygonArea(polygon: Polygon): number | null;
  /**
    * Calculate the centroid of a polygon
    *
    * Returns null if the polygon is invalid or degenerate (i.e. all vertices are
    * collinear)
    */
  export function polygonCentroid(polygon: Polygon): Point | null;
  /**
    * Calculate the convex hull of a polygon
    */
  export function polygonConvexHull(polygon: Polygon, options?: {
      /**
        * Whether or not the convex hull should keep the same winding order as the
        * original polygon. Default value is true
        *
        * If this is false, the convex hull will always be returned in
        * counter-clockwise winding order
        */
      keepWindingOrder?: boolean;
  }): Polygon | null;
  /**
    * Optimise a polygon by removing collinear vertices and duplicate adjacent
    * vertices
    */
  export function optimisePolygon(polygon: Polygon): Polygon | null;
  /**
    * Decompose a polygon into a set of convex polygons using the Bayazit
    * algorithm
    *
    * Returns null if the polygon is invalid or cannot be decomposed
    */
  export function decomposePolygon(polygon: Polygon, options?: {
      /**
        * The mode of decomposition: 'fast' uses a quick decomposition
        * algorithm that may not always produce the optimal result, while 'optimal'
        * uses a more complex algorithm that guarantees the best result
        * but is slower. Default is 'fast'
        */
      mode?: 'fast' | 'optimal';
      /**
        * Whether or not the convex polygons should keep the same winding
        * order as the original polygon. Default value is true
        *
        * If this is false, the convex polygons will be returned in whichever
        * winding order the decomposition algorithm produces (generally this is
        * clockwise, but it's not guaranteed; it could return a mixture of
        * clockwise and counter-clockwise winding orders)
        */
      keepWindingOrder?: boolean;
  }): Polygon[] | null;
  /**
    * Check if a point is on a ray
    */
  export function pointOnRay(point: Point, ray: Ray): {
      /**
        * Whether the point is on the ray
        */
      intersects: boolean;
      /**
        * The closest point on the ray to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the ray
        */
      distance: number;
  };
  /**
    * Check if a point intersects a line segment
    */
  export function pointOnLine(point: Point, line: Line): {
      /**
        * Whether the point intersects the line segment
        */
      intersects: boolean;
      /**
        * The closest point on the line segment to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the line segment
        */
      distance: number;
  };
  /**
    * Check if a point is inside a circle
    */
  export function pointInCircle(point: Point, circle: Circle): {
      /**
        * Whether the point is inside the circle
        */
      intersects: boolean;
      /**
        * The closest point on the circle edge to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the circle edge
        *
        * If the point is inside the circle, this will be negative
        */
      distance: number;
  };
  /**
    * Check if a point is inside a rectangle
    *
    * In cases where the closest point is ambiguous (e.g. corners), the first edge
    * encountered with a closest point will be returned after evaluating edges in
    * this order:
    * top, right, bottom, left (before applying the rectangle's rotation)
    */
  export function pointInRectangle(point: Point, rectangle: Rectangle): {
      /**
        * Whether the point is inside the rectangle
        */
      intersects: boolean;
      /**
        * The closest point on the rectangle edge to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the rectangle edge
        *
        * If the point is inside the rectangle, this will be negative
        */
      distance: number;
  };
  /**
    * Check if a point is inside a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function pointInPolygon(point: Point, polygon: Polygon): {
      /**
        * Whether the point is inside the polygon
        */
      intersects: boolean;
      /**
        * The closest point on the polygon edge to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the polygon edge
        *
        * If the point is inside the polygon, this will be negative
        */
      distance: number;
  } | null;
  /**
    * Check which grid cells a ray traverses
    *
    * Based on "A Fast Voxel Traversal Algorithm for Ray Tracing" by Amanatides
    * and Woo
    *
    * We can optionally limit the number of cells traversed by the ray, or set
    * maxCells to -1 to continue traversing until the ray exits the grid (or until
    * we hit the hard limit of 10000 cells).
    */
  export function rayTraverseGrid(ray: Ray, cellSize: number, gridTopLeft: vec2, gridBottomRight: vec2, maxCells?: number): {
      cells: Point[];
  };
  /**
    * Check if two rays intersect
    */
  export function rayIntersectsRay(rayA: Ray, rayB: Ray): {
      /**
        * Whether the rays intersect
        */
      intersects: boolean;
      /**
        * The intersection point if the rays intersect
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a ray intersects a line segment
    */
  export function rayIntersectsLine(ray: Ray, line: Line): {
      /**
        * Whether the ray intersects the line segment
        */
      intersects: boolean;
      /**
        * The intersection point if the ray intersects the line segment
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a ray intersects a circle
    */
  export function rayIntersectsCircle(ray: Ray, circle: Circle): {
      /**
        * Whether the ray intersects the circle
        */
      intersects: boolean;
      /**
        * The intersection points if the ray intersects the circle
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a ray intersects a rectangle
    */
  export function rayIntersectsRectangle(ray: Ray, rectangle: Rectangle): {
      /**
        * Whether the ray intersects the rectangle
        */
      intersects: boolean;
      /**
        * The intersection points if the ray intersects the rectangle
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a ray intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function rayIntersectsPolygon(ray: Ray, polygon: Polygon): {
      /**
        * Whether the ray intersects the polygon
        */
      intersects: boolean;
      /**
        * The intersection points if the ray intersects the polygon
        */
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if a line segment intersects a ray
    */
  export function lineIntersectsRay(line: Line, ray: Ray): {
      /**
        * Whether the line segment intersects the ray
        */
      intersects: boolean;
      /**
        * The intersection point if the line segment intersects the ray
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if two line segments intersect
    */
  export function lineIntersectsLine(lineA: Line, lineB: Line): {
      /**
        * Whether the line segments intersect
        */
      intersects: boolean;
      /**
        * The intersection point if the line segments intersect
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a line segment intersects a circle
    */
  export function lineIntersectsCircle(line: Line, circle: Circle): {
      /**
        * Whether the line segment intersects the circle
        */
      intersects: boolean;
      /**
        * The intersection points if the line segment intersects the circle
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a line segment intersects a rectangle
    */
  export function lineIntersectsRectangle(line: Line, rectangle: Rectangle): {
      /**
        * Whether the line segment intersects the rectangle
        */
      intersects: boolean;
      /**
        * The intersection points if the line segment intersects the rectangle
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a line segment intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function lineIntersectsPolygon(line: Line, polygon: Polygon): {
      /**
        * Whether the line segment intersects the polygon
        */
      intersects: boolean;
      /**
        * The intersection points if the line segment intersects the polygon
        */
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if two circles intersect
    */
  export function circleIntersectsCircle(circleA: Circle, circleB: Circle): {
      /**
        * Whether the circles intersect
        */
      intersects: boolean;
      /**
        * The intersection points on each circle's circumference if the circles
        * intersect
        */
      intersectionPoints?: Point[];
      /**
        * The minimum separation vector between the circles if they intersect
        */
      minimumSeparation?: vec2;
  };
  /**
    * Check if a circle intersects a rectangle
    */
  export function circleIntersectsRectangle(circle: Circle, rectangle: Rectangle): {
      /**
        * Whether the circle intersects the rectangle
        */
      intersects: boolean;
      /**
        * The intersection points on the rectangle's edges if the circle intersects
        * the rectangle
        */
      intersectionPoints?: Point[];
      /**
        * The minimum separation vector between the circle and rectangle if they
        * intersect
        */
      minimumSeparation?: vec2;
  };
  /**
    * Check if a circle intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function circleIntersectsPolygon(circle: Circle, polygon: Polygon, options?: {
      /**
        * Whether to find the minimum separation vector between the circle and
        * polygon if they intersect. Default is false
        */
      findMinimumSeparation?: boolean;
  }): {
      /**
        * Whether the circle intersects the polygon
        */
      intersects: boolean;
      /**
        * The intersection points on the polygon's edges if the circle intersects
        * the polygon
        */
      intersectionPoints?: Point[];
      /**
        * The minimum separation vector between the circle and polygon if they
        * intersect and `findMinimumSeparation` is true
        */
      minimumSeparation?: vec2;
  } | null;
  /**
    * Check if two rectangles intersect
    */
  export function rectangleIntersectsRectangle(rectangleA: Rectangle, rectangleB: Rectangle): {
      /**
        * Whether the rectangles intersect
        */
      intersects: boolean;
      /**
        * The intersection points on the edges of the rectangles if they intersect
        */
      intersectionPoints?: Point[];
      /**
        * The minimum separation vector between the rectangles if they intersect
        */
      minimumSeparation?: vec2;
  };
  /**
    * Check if a rectangle intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function rectangleIntersectsPolygon(rectangle: Rectangle, polygon: Polygon): {
      /**
        * Whether the rectangle intersects the polygon
        */
      intersects: boolean;
      /**
        * The intersection points on the polygon's edges if the rectangle intersects
        * the polygon
        */
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if two polygons intersect
    *
    * Returns null if either polygon is invalid
    */
  export function polygonIntersectsPolygon(polygonA: Polygon, polygonB: Polygon): {
      /**
        * Whether the polygons intersect
        */
      intersects: boolean;
      /**
        * The intersection points on the edges of the polygons if they intersect
        */
      intersectionPoints?: Point[];
  } | null;
}

declare module '@basementuniverse/intersection-helpers/src/3d' {
  import { vec3 } from '@basementuniverse/vec';
  import { AABB, Cuboid, Line, Mesh, Plane, Point, Polygon, Ray, Sphere } from '@basementuniverse/intersection-helpers/src/3d/types';
  export * from '@basementuniverse/intersection-helpers/src/3d/types';
  /**
    * Calculate the distance between two points in 3D space
    */
  export function distance(a: Point, b: Point): number;
  /**
    * Calculate the Euler angle from point a to point b
    */
  export function angle(a: Point, b: Point): vec3;
  /**
    * Calculate the angle between two lines or rays
    *
    * Returns 0 if either line is zero-length
    */
  export function angleBetween(a: Line | Ray, b: Line | Ray): number;
  /**
    * Check if three points in 3D space are collinear
    */
  export function pointsAreCollinear(a: Point, b: Point, c: Point): boolean;
  /**
    * Convert a line segment to a ray
    */
  export function lineToRay(line: Line): Ray;
  /**
    * Convert a ray to a line segment
    */
  export function rayToLine(ray: Ray, length?: number): Line;
  /**
    * Get the bounding box (AABB) of a geometric object
    */
  export function aabb(o: Line | Sphere | Cuboid | Polygon | Mesh): AABB | null;
  /**
    * Convert an AABB to a cuboid
    */
  export function aabbToCuboid(aabb: AABB): Cuboid;
  /**
    * Check if two AABBs overlap and return the overlapping volume if they do
    */
  export function aabbsOverlap(a: AABB, b: AABB): {
      /**
        * Whether the two AABBs overlap
        */
      intersects: boolean;
      /**
        * The overlapping volume as an AABB
        */
      overlap?: AABB;
  };
  /**
    * Check if a point is inside an AABB
    *
    * This should be a bit faster than pointInRectangle since we don't need to
    * worry about rotation
    */
  export function pointInAABB(point: Point, aabb: AABB): {
      /**
        * Whether the point is inside the AABB
        */
      intersects: boolean;
      /**
        * The closest point on the AABB surface to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the AABB
        *
        * If the point is inside the AABB, this will be negative
        */
      distance: number;
  };
  /**
    * Check if a cuboid is rotated
    */
  export function cuboidIsRotated(cuboid: Cuboid): boolean;
  /**
    * Get the vertices of a cuboid
    *
    * Vertices will be returned in the following order:
    * - Upper face (max z, clockwise starting at the top-left)
    *   - Top-left
    *   - Top-right
    *   - Bottom-right
    *   - Bottom-left
    * - Lower face (min z, clockwise starting at the top-left)
    *   - Top-left
    *   - Top-right
    *   - Bottom-right
    *   - Bottom-left
    */
  export function cuboidVertices(cuboid: Cuboid): Point[];
  /**
    * Convert a cuboid to a list of polygons representing its faces
    *
    * Polygons will be returned in the following order:
    * - Upper face (top)
    * - Lower face (bottom)
    * - Front face
    * - Back face
    * - Left face
    * - Right face
    */
  export function cuboidToPolygons(cuboid: Cuboid): Polygon[];
  /**
    * Convert a list of vertices to a list of edges
    */
  export function verticesToEdges(vertices: Point[]): Line[];
  /**
    * Check if a polygon is valid
    *
    * A polygon is valid if it has exactly 3 vertices
    */
  export function polygonIsValid(polygon: Polygon): boolean;
  /**
    * Determine the winding order of a polygon's vertices
    *
    * Returns 'clockwise' or 'counter-clockwise'
    *
    * By default uses the right-hand rule: if the vertices are ordered
    * counter-clockwise, the normal points towards the viewer
    *
    * Returns null if the polygon is invalid or degenerate
    */
  export function polygonWindingOrder(polygon: Polygon, options?: {
      /**
        * Which hand rule to use for determining winding order
        * - 'right' (default): Counter-clockwise vertices create a normal pointing
        *   towards viewer
        * - 'left': Clockwise vertices create a normal pointing towards viewer
        */
      handedness?: 'right' | 'left';
      /**
        * Optional normal vector to use as reference
        *
        * If provided, winding order will be determined relative to this vector
        */
      normal?: Point;
  }): 'clockwise' | 'counter-clockwise' | null;
  /**
    * Calculate the 2D area of a polygon in 3D space
    *
    * Returns null if the polygon is invalid
    */
  export function polygonArea(polygon: Polygon): number | null;
  /**
    * Calculate the centroid of a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function polygonCentroid(polygon: Polygon): Point | null;
  /**
    * Convert a polygon to a plane
    */
  export function polygonToPlane(polygon: Polygon): Plane | null;
  /**
    * Convert a list of polygons to a mesh
    *
    * This optimises the number of vertices and edges by merging common vertices
    */
  export function polygonsToMesh(polygons: Polygon[]): Mesh;
  /**
    * Convert a mesh to a list of polygons
    */
  export function meshToPolygons(mesh: Mesh): Polygon[];
  /**
    * Convert a mesh to a list of edges
    */
  export function meshToEdges(mesh: Mesh): Line[];
  /**
    * Calculate the centroid of a mesh
    */
  export function meshCentroid(mesh: Mesh): Point;
  /**
    * Perform an edge manifold check to tell if a mesh is watertight
    *
    * Every edge in a watertight mesh should be shared by exactly two triangles
    *
    * This isn't perfect, but it should be sufficient for most simple cases
    */
  export function meshIsWatertight(mesh: Mesh): boolean;
  /**
    * Check if a point is on a ray
    *
    * Also returns the closest point on the ray and the distance to it
    */
  export function pointOnRay(point: Point, ray: Ray): {
      /**
        * Whether the point is on the ray
        */
      intersects: boolean;
      /**
        * The closest point on the ray to the given point
        */
      closestPoint?: Point;
      /**
        * The distance from the point to the closest point on the ray
        */
      distance: number;
  };
  /**
    * Check if a point intersects a line segment
    *
    * Also returns the closest point on the line segment and the distance to it
    */
  export function pointOnLine(point: Point, line: Line): {
      /**
        * Whether the point is on the line segment
        */
      intersects: boolean;
      /**
        * The closest point on the line segment to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the line segment
        */
      distance: number;
  };
  /**
    * Check if a point is inside a sphere
    *
    * Also returns the closest point on the sphere edge and the distance to it
    *
    * If the point is inside the sphere, the distance will be negative
    */
  export function pointInSphere(point: Point, sphere: Sphere): {
      /**
        * Whether the point is in the sphere
        */
      intersects: boolean;
      /**
        * The closest point on the sphere surface to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the sphere
        *
        * If the point is inside the sphere, this will be negative
        */
      distance: number;
  };
  /**
    * Check if a point is inside a cuboid
    */
  export function pointInCuboid(point: Point, cuboid: Cuboid): {
      /**
        * Whether the point is inside the cuboid
        */
      intersects: boolean;
      /**
        * The closest point on the cuboid surface to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the cuboid
        *
        * If the point is inside the cuboid, this will be negative
        */
      distance: number;
  };
  export function pointOnPolygon(point: Point, polygon: Polygon): {
      /**
        * Whether the point intersects the polygon
        */
      intersects: boolean;
      /**
        * The closest point on the polygon to the given point
        */
      closestPoint: Point;
      /**
        * The distance from the point to the closest point on the polygon
        */
      distance: number;
  } | null;
  /**
    * Check which grid cells a ray traverses
    *
    * Based on "A Fast Voxel Traversal Algorithm for Ray Tracing" by Amanatides
    * and Woo
    *
    * We can optionally limit the number of cells traversed by the ray, or set
    * maxCells to -1 to continue traversing until the ray exits the grid (or until
    * we hit the hard limit of 10000 cells).
    */
  export function rayTraverseGrid(ray: Ray, cellSize: number, gridTopLeftFront: vec3, gridBottomRightBack: vec3, maxCells?: number): {
      cells: Point[];
  };
  /**
    * Check if two rays intersect
    */
  export function rayIntersectsRay(rayA: Ray, rayB: Ray): {
      /**
        * Whether the rays intersect
        */
      intersects: boolean;
      /**
        * The intersection point if the rays intersect
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a ray intersects a line segment
    */
  export function rayIntersectsLine(ray: Ray, line: Line): {
      /**
        * Whether the ray intersects the line segment
        */
      intersects: boolean;
      /**
        * The intersection point if the ray intersects the line segment
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a ray intersects a sphere
    */
  export function rayIntersectsSphere(ray: Ray, sphere: Sphere): {
      /**
        * Whether the ray intersects the sphere
        */
      intersects: boolean;
      /**
        * The intersection points if the ray intersects the sphere
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a ray intersects a plane
    */
  export function rayIntersectsPlane(ray: Ray, plane: Plane): {
      /**
        * Whether the ray intersects the plane
        */
      intersects: boolean;
      /**
        * The intersection point if the ray intersects the plane
        *
        * If the ray lies in the plane, this will be undefined since there are
        * infinite intersection points
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a ray intersects a cuboid
    */
  export function rayIntersectsCuboid(ray: Ray, cuboid: Cuboid): {
      /**
        * Whether the ray intersects the cuboid
        */
      intersects: boolean;
      /**
        * The intersection points if the ray intersects the cuboid
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a ray intersects a polygon
    */
  export function rayIntersectsPolygon(ray: Ray, polygon: Polygon): {
      /**
        * Whether the ray intersects the polygon
        */
      intersects: boolean;
      /**
        * The intersection point if the ray intersects the polygon
        */
      intersectionPoint?: Point;
  } | null;
  /**
    * Check if a ray intersects any of the polygons in a mesh
    */
  export function rayIntersectsMesh(ray: Ray, mesh: Mesh): {
      /**
        * Whether the ray intersects any polygon in the mesh
        */
      intersects: boolean;
      /**
        * The intersection points if the ray intersects any polygon in the mesh
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a line segment intersects a ray
    */
  export function lineIntersectsRay(line: Line, ray: Ray): {
      /**
        * Whether the line segment intersects the ray
        */
      intersects: boolean;
      /**
        * The intersection point if the line segment intersects the ray
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if two line segments intersect
    */
  export function lineIntersectsLine(lineA: Line, lineB: Line): {
      /**
        * Whether the two line segments intersect
        */
      intersects: boolean;
      /**
        * The intersection point if the line segments intersect
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a line segments intersects a sphere
    */
  export function lineIntersectsSphere(line: Line, sphere: Sphere): {
      /**
        * Whether the line segment intersects the sphere
        */
      intersects: boolean;
      /**
        * The intersection points if the line segment intersects the sphere
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a line segments intersects a plane
    */
  export function lineIntersectsPlane(line: Line, plane: Plane): {
      /**
        * Whether the line segment intersects the plane
        */
      intersects: boolean;
      /**
        * The intersection point if the line segment intersects the plane
        *
        * If the line segment lies in the plane, this will be undefined since there
        * are infinite intersection points
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a line segment intersects a cuboid
    */
  export function lineIntersectsCuboid(line: Line, cuboid: Cuboid): {
      /**
        * Whether the line segment intersects the cuboid
        */
      intersects: boolean;
      /**
        * The intersection points if the line segment intersects the cuboid
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if a line segment intersects a polygon
    */
  export function lineIntersectsPolygon(line: Line, polygon: Polygon): {
      /**
        * Whether the line segment intersects the polygon
        */
      intersects: boolean;
      /**
        * The intersection point if the line segment intersects the polygon
        */
      intersectionPoint?: Point;
  };
  /**
    * Check if a line segment intersects a cuboid
    */
  export function lineIntersectsMesh(line: Line, mesh: Mesh): {
      /**
        * Whether the line segment intersects any polygon in the mesh
        */
      intersects: boolean;
      /**
        * The intersection points if the line segment intersects any polygon in the
        * mesh
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if two spheres intersect
    */
  export function sphereIntersectsSphere(sphereA: Sphere, sphereB: Sphere): {
      /**
        * Whether the spheres intersect
        */
      intersects: boolean;
      /**
        * The point at the center of the intersection volume
        */
      intersectionPoint?: Point;
      /**
        * How deeply the spheres are intersecting
        */
      penetrationDepth?: number;
      /**
        * Unit vector pointing from sphere A to sphere B
        */
      normal?: Point;
      /**
        * The closest points on each sphere's surface along the intersection axis
        */
      contactPoints?: {
          sphereA: Point;
          sphereB: Point;
      };
  };
  /**
    * Check if a sphere intersects a plane
    */
  export function sphereIntersectsPlane(sphere: Sphere, plane: Plane): {
      /**
        * Whether the sphere intersects the plane
        */
      intersects: boolean;
      /**
        * The point at the center of the intersection volume
        */
      intersectionPoint?: Point;
      /**
        * How deeply the spheres are intersecting
        */
      penetrationDepth?: number;
      /**
        * The radius of the intersection volume
        */
      intersectionRadius?: number;
  };
  /**
    * Check if a sphere intersects a cuboid
    */
  export function sphereIntersectsCuboid(sphere: Sphere, cuboid: Cuboid): {
      /**
        * Whether the sphere intersects the cuboid
        */
      intersects: boolean;
      /**
        * The point at the center of the intersection volume
        */
      intersectionPoint?: Point;
      /**
        * How deeply the sphere penetrates the cuboid
        */
      penetrationDepth?: number;
      /**
        * Direction of minimum separation (unit vector)
        * Points from cuboid center towards sphere center
        */
      normal?: Point;
      /**
        * Closest point on cuboid surface to sphere center
        */
      contactPoint?: Point;
  };
  /**
    * Check if a sphere intersects a polygon
    */
  export function sphereIntersectsPolygon(sphere: Sphere, polygon: Polygon): {
      /**
        * Whether the sphere intersects the polygon
        */
      intersects: boolean;
      /**
        * The point at the center of the intersection volume
        */
      intersectionPoint?: Point;
      /**
        * How deeply the sphere is intersecting
        */
      penetrationDepth?: number;
      /**
        * Points where the sphere surface intersects the polygon edges, if any
        */
      polygonIntersectionPoints?: Point[];
  } | null;
  /**
    * Check if a sphere intersects any polygon in a mesh
    */
  export function sphereIntersectsMesh(sphere: Sphere, mesh: Mesh): {
      /**
        * Whether the sphere intersects any polygon in the mesh
        */
      intersects: boolean;
      /**
        * The intersection points if the sphere intersects any polygon in the mesh
        */
      intersectionPoints?: Point[];
      /**
        * The intersection points on the polygons if any
        */
      polygonIntersectionPoints?: Point[];
  };
  /**
    * Check if two planes intersect
    *
    * Based on the algorithm described in "Real-Time Collision Detection" by
    * Christer Ericson
    */
  export function planeIntersectsPlane(planeA: Plane, planeB: Plane): {
      /**
        * Whether the planes intersect
        *
        * Will be false only if the planes are parallel with a gap between them
        */
      intersects: boolean;
      /**
        * The line where the planes intersect
        *
        * Will be undefined if:
        * - The planes don't intersect (parallel with gap)
        * - The planes are coincident (infinite intersection)
        */
      intersectionLine?: Line;
  };
  /**
    * Check if a plane intersects one or more polygons in a mesh
    */
  export function planeIntersectsMesh(plane: Plane, mesh: Mesh): {
      /**
        * Whether any polygon in the mesh intersects the plane
        */
      intersects: boolean;
      /**
        * The points where the mesh's edges intersect the plane
        *
        * Will be undefined if:
        * - The mesh doesn't intersect the plane
        * - The mesh lies entirely in the plane
        */
      intersectionPoints?: Point[];
      /**
        * How deeply the mesh penetrates the plane in the direction opposite to
        * the plane's normal
        */
      penetrationDepth?: number;
  };
  /**
    * Check if two cuboids intersect using the Separating Axis Theorem
    */
  export function cuboidIntersectsCuboid(cuboidA: Cuboid, cuboidB: Cuboid): {
      /**
        * Whether the cuboids intersect
        */
      intersects: boolean;
      /**
        * The approximate point at the center of the intersection volume
        */
      intersectionPoint?: Point;
      /**
        * How deeply the cuboids are intersecting along the minimum separation axis
        */
      penetrationDepth?: number;
      /**
        * Direction of minimum separation (unit vector)
        * Points from cuboid A to cuboid B
        */
      normal?: Point;
      /**
        * The closest points on each cuboid's surface along the separation axis
        */
      contactPoints?: {
          cuboidA: Point;
          cuboidB: Point;
      };
  };
  /**
    * Check if a cuboid intersects a plane
    */
  export function cuboidIntersectsPlane(cuboid: Cuboid, plane: Plane): {
      /**
        * Whether the cuboid intersects the plane
        */
      intersects: boolean;
      /**
        * The points where the cuboid's edges intersect the plane
        */
      intersectionPoints?: Point[];
      /**
        * How deeply the cuboid penetrates the plane in the direction opposite to
        * the plane's normal
        */
      penetrationDepth?: number;
  };
  /**
    * Check if a cuboid intersects a polygon
    */
  export function cuboidIntersectsPolygon(cuboid: Cuboid, polygon: Polygon): {
      /**
        * Whether the cuboid intersects the polygon
        */
      intersects: boolean;
      /**
        * The points where the cuboid's edges intersect the polygon
        *
        * Will be undefined if:
        * - The polygon is entirely inside the cuboid
        * - The polygon is coincident with a cuboid face
        * - There are no intersections
        */
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if a cuboid intersects any polygon in a mesh
    */
  export function cuboidIntersectsMesh(cuboid: Cuboid, mesh: Mesh): {
      /**
        * Whether the cuboid intersects any polygon in the mesh
        */
      intersects: boolean;
      /**
        * The points where the cuboid intersects the mesh's polygons
        *
        * Will be undefined if:
        * - There are no intersections
        * - A polygon is entirely inside the cuboid
        * - A polygon is coincident with a cuboid face
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if two polygons intersect
    */
  export function polygonIntersectsPolygon(polygonA: Polygon, polygonB: Polygon): {
      /**
        * Whether the polygons intersect
        */
      intersects: boolean;
      /**
        * The points where the polygons intersect
        *
        * Will be undefined if:
        * - The polygons don't intersect
        * - The polygons are coplanar and overlapping (infinite intersection points)
        */
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if a polygon intersects a plane
    */
  export function polygonIntersectsPlane(polygon: Polygon, plane: Plane): {
      /**
        * Whether the polygon intersects the plane
        *
        * Will be true if:
        * - The polygon intersects the plane at one or more points
        * - The polygon lies entirely in the plane
        */
      intersects: boolean;
      /**
        * The points where the polygon's edges intersect the plane
        *
        * Will be undefined if:
        * - The polygon doesn't intersect the plane
        * - The polygon lies entirely in the plane (infinite intersection points)
        */
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if a polygon intersects any polygon in a mesh
    */
  export function polygonIntersectsMesh(polygon: Polygon, mesh: Mesh): {
      /**
        * Whether the polygon intersects any polygon in the mesh
        */
      intersects: boolean;
      /**
        * The points where the polygon intersects the mesh's polygons
        *
        * Will be undefined if:
        * - There are no intersections
        * - The polygons are coplanar and overlapping
        */
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if two meshes intersect using their polygons
    */
  export function meshIntersectsMesh(meshA: Mesh, meshB: Mesh): {
      /**
        * Whether any polygons in either mesh intersect with polygons from the other
        * mesh
        */
      intersects: boolean;
      /**
        * The points where the polygons intersect
        */
      intersectionPoints?: Point[];
  };
  /**
    * Check if any polygons in a mesh intersect a plane
    */
  export function meshIntersectsPlane(mesh: Mesh, plane: Plane): {
      /**
        * Whether any polygon in the mesh intersects the plane
        */
      intersects: boolean;
      /**
        * The points where the mesh's edges intersect the plane
        *
        * Will be undefined if:
        * - The mesh doesn't intersect the plane
        * - The mesh lies entirely in the plane
        */
      intersectionPoints?: Point[];
      /**
        * How deeply the mesh penetrates the plane in the direction opposite to
        * the plane's normal
        */
      penetrationDepth?: number;
  };
}

declare module '@basementuniverse/intersection-helpers/src/utilities' {
  import { vec2, vec3 } from '@basementuniverse/vec';
  import { Interval } from '@basementuniverse/intersection-helpers/src/utilities/types';
  export * from '@basementuniverse/intersection-helpers/src/utilities/types';
  /**
    * Check if a vector is almost zero
    */
  export function vectorAlmostZero(v: vec2): boolean;
  export function vectorAlmostZero(v: vec3): boolean;
  /**
    * Check if two vectors are almost equal
    */
  export function vectorsAlmostEqual(a: vec2, b: vec2): boolean;
  export function vectorsAlmostEqual(a: vec3, b: vec3): boolean;
  /**
    * Check if a value is within a specified interval
    */
  export function valueInInterval(value: number, interval: Interval): boolean;
  /**
    * Check if two intervals (a1, a2) and (b1, b2) overlap
    */
  export function intervalsOverlap(a: Interval, b: Interval): boolean;
  /**
    * Get the overlapping part of two intervals (a1, a2) and (b1, b2)
    *
    * If the intervals do not overlap, return null
    */
  export function overlapInterval(a: Interval, b: Interval): Interval | null;
}

declare module '@basementuniverse/intersection-helpers/src/2d/types' {
  import { vec2 } from '@basementuniverse/vec';
  /**
    * A point in 2D space
    */
  export type Point = vec2;
  /**
    * Type guard to check if a value is a Point
    */
  export function isPoint(value: any): value is Point;
  /**
    * A ray that extends infinitely in one direction
    */
  export type Ray = {
      origin: Point;
      direction: vec2;
  };
  /**
    * Check if a value is a Ray
    */
  export function isRay(value: any): value is Ray;
  /**
    * A line segment defined by two endpoints
    */
  export type Line = {
      start: Point;
      end: Point;
  };
  /**
    * Check if a value is a Line
    */
  export function isLine(value: any): value is Line;
  /**
    * A circle defined by its center and radius
    */
  export type Circle = {
      position: Point;
      radius: number;
  };
  /**
    * Check if a value is a Circle
    */
  export function isCircle(value: any): value is Circle;
  /**
    * An axis-aligned bounding box (AABB) defined by the position of its top-left
    * corner and its width and height
    */
  export type AABB = {
      position: Point;
      size: vec2;
  };
  /**
    * Check if a value is an AABB
    */
  export function isAABB(value: any): value is AABB;
  /**
    * A rectangle defined by the position of its center, side lengths, and
    * optional rotation
    *
    * Rotation is in radians and is applied around the center of the rectangle
    */
  export type Rectangle = {
      position: Point;
      size: vec2;
      rotation?: number;
  };
  /**
    * Check if a value is a Rectangle
    */
  export function isRectangle(value: any): value is Rectangle;
  /**
    * A polygon defined by its vertices
    *
    * Vertices can be ordered in clockwise or counter-clockwise winding order
    */
  export type Polygon = {
      vertices: Point[];
  };
  /**
    * Check if a value is a Polygon
    */
  export function isPolygon(value: any): value is Polygon;
}

declare module '@basementuniverse/intersection-helpers/src/3d/types' {
  import { vec3 } from '@basementuniverse/vec';
  /**
    * A point in 3D space
    */
  export type Point = vec3;
  /**
    * Type guard to check if a value is a Point
    */
  export function isPoint(value: any): value is Point;
  /**
    * A ray that extends infinitely in one direction
    */
  export type Ray = {
      origin: Point;
      direction: vec3;
  };
  /**
    * Check if a value is a Ray
    */
  export function isRay(value: any): value is Ray;
  /**
    * A line segment defined by two endpoints
    */
  export type Line = {
      start: Point;
      end: Point;
  };
  /**
    * Check if a value is a Line
    */
  export function isLine(value: any): value is Line;
  /**
    * A sphere defined by its center and radius
    */
  export type Sphere = {
      position: Point;
      radius: number;
  };
  /**
    * Check if a value is a Sphere
    */
  export function isSphere(value: any): value is Sphere;
  /**
    * An axis-aligned bounding box (AABB) defined by the position of its top-left
    * corner and its width, height, and depth
    */
  export type AABB = {
      position: Point;
      size: vec3;
  };
  /**
    * Check if a value is an AABB
    */
  export function isAABB(value: any): value is AABB;
  /**
    * A cuboid defined by the position of its center, side lengths, and
    * optional rotation
    *
    * Rotation is represented as Euler angles measured in radians and is applied
    * around the center of the rectangle
    */
  export type Cuboid = {
      position: Point;
      size: vec3;
      rotation?: vec3;
  };
  /**
    * Check if a value is a Cuboid
    */
  export function isCuboid(value: any): value is Cuboid;
  /**
    * A plane defined by a point on the plane and a normal vector
    */
  export type Plane = {
      point: Point;
      normal: vec3;
  };
  /**
    * Check if a value is a Plane
    */
  export function isPlane(value: any): value is Plane;
  /**
    * A polygon (triangle in 3D space) defined by three vertices
    */
  export type Polygon = {
      vertices: [Point, Point, Point];
  };
  /**
    * Check if a value is a Polygon
    */
  export function isPolygon(value: any): value is Polygon;
  /**
    * A mesh defined by its vertices and indices
    *
    * Vertices are points in 3D space, and indices define how these vertices
    * are connected to form triangles
    */
  export type Mesh = {
      vertices: Point[];
      indices: number[];
  };
  /**
    * Check if a value is a Mesh
    */
  export function isMesh(value: any): value is Mesh;
}

declare module '@basementuniverse/intersection-helpers/src/utilities/types' {
  import { vec2, vec3 } from '@basementuniverse/vec';
  /**
    * A numeric interval with optional inclusivity
    */
  export type Interval = {
      min: number;
      minInclusive?: boolean;
      max: number;
      maxInclusive?: boolean;
  };
  /**
    * Check if a value is a vec2
    */
  export function isVec2(value: any): value is vec2;
  /**
    * Check if a value is a vec3
    */
  export function isVec3(value: any): value is vec3;
}

