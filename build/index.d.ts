// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@basementuniverse/vec

declare module '@basementuniverse/intersection-helpers' {
  export * as intersection2d from '@basementuniverse/intersection-helpers/src/2d';
  export * as intersection3d from '@basementuniverse/intersection-helpers/src/3d';
  export * as intersectionUtilities from '@basementuniverse/intersection-helpers/src/utilities';
}

declare module '@basementuniverse/intersection-helpers/src/2d' {
  import { vec2 } from '@basementuniverse/vec';
  import { AABB, Circle, Line, Point, Polygon, Ray, Rectangle } from '@basementuniverse/intersection-helpers/src/2d/types';
  export * from '@basementuniverse/intersection-helpers/src/2d/types';
  /**
    * Calculate the distance between two points
    */
  export function distance(a: Point, b: Point): number;
  /**
    * Calculate the clockwise angle from vector a to vector b
    *
    * The result is in radians and ranges from 0 to 2Ï€ (360 degrees)
    * A positive angle indicates clockwise rotation from a to b
    *
    * Returns 0 if either vector is zero-length or if they are equal
    */
  export function angleBetween(a: vec2, b: vec2): number;
  /**
    * Check if points are collinear
    */
  export function pointsAreCollinear(a: Point, b: Point, c: Point): boolean;
  /**
    * Convert a line segment to a ray
    */
  export function lineToRay(line: Line): Ray;
  /**
    * Convert a ray to a line segment
    */
  export function rayToLine(ray: Ray, length?: number): Line;
  /**
    * Get the bounding box (AABB) of a geometric object
    */
  export function aabb(o: Line | Rectangle | Circle | Polygon): AABB | null;
  /**
    * Convert an AABB to a rectangle
    */
  export function aabbToRectangle(aabb: AABB): Rectangle;
  /**
    * Check if two AABBs overlap and return the overlapping area if so
    */
  export function aabbsOverlap(a: AABB, b: AABB): {
      intersects: boolean;
      overlap?: AABB;
  };
  /**
    * Check if a rectangle is rotated
    */
  export function rectangleIsRotated(rectangle: Rectangle): boolean;
  /**
    * Get the vertices of a rectangle
    *
    * Vertices will be returned in clockwise order starting at the top-left:
    * top-left, top-right, bottom-right, bottom-left
    */
  export function rectangleVertices(rectangle: Rectangle): Point[];
  /**
    * Check if a polygon is convex
    *
    * Returns null if the polygon is invalid
    */
  export function polygonIsConvex(polygon: Polygon): boolean | null;
  /**
    * Check if a polygon self-intersects
    */
  export function polygonSelfIntersects(polygon: Polygon): boolean;
  /**
    * Check if a polygon is valid
    *
    * A polygon is valid if it has at least 3 vertices and does not
    * self-intersect
    */
  export function polygonIsValid(polygon: Polygon): boolean;
  /**
    * Determine the winding order of a polygon's vertices
    *
    * Returns 'clockwise' or 'counter-clockwise'
    *
    * Returns null if the polygon is invalid
    */
  export function polygonWindingOrder(polygon: Polygon): 'clockwise' | 'counter-clockwise' | null;
  /**
    * Calculate the area of a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function polygonArea(polygon: Polygon): number | null;
  /**
    * Calculate the centroid of a polygon
    *
    * Returns null if the polygon is invalid or degenerate (i.e. all vertices are
    * collinear)
    */
  export function polygonCentroid(polygon: Polygon): Point | null;
  /**
    * Optimise a polygon by removing collinear vertices and duplicate adjacent
    * vertices
    */
  export function optimisePolygon(polygon: Polygon): Polygon | null;
  /**
    * Decompose a polygon into a set of convex polygons using the Bayazit
    * algorithm
    *
    * Returns null if the polygon is invalid or cannot be decomposed
    */
  export function decomposePolygon(polygon: Polygon, options?: {
      mode?: 'fast' | 'optimal';
      keepWindingOrder?: boolean;
  }): Polygon[] | null;
  /**
    * Check if a point is on a ray
    *
    * Also returns the closest point on the ray and the distance to it
    */
  export function pointOnRay(point: Point, ray: Ray): {
      intersects: boolean;
      closestPoint: Point;
      distance: number;
  };
  /**
    * Check if a point intersects a line segment
    *
    * Also returns the closest point on the line segment and the distance to it
    */
  export function pointOnLine(point: Point, line: Line): {
      intersects: boolean;
      closestPoint: Point;
      distance: number;
  };
  /**
    * Check if a point is inside a circle
    *
    * Also returns the closest point on the circle edge and the distance to it
    *
    * If the point is inside the circle, the distance will be negative
    */
  export function pointInCircle(point: Point, circle: Circle): {
      intersects: boolean;
      closestPoint: Point;
      distance: number;
  };
  /**
    * Check if a point is inside a rectangle
    *
    * Also returns the closest point on the rectangle edge and the distance to it
    *
    * If the point is inside the rectangle, the distance will be negative
    *
    * In cases where the closest point is ambiguous (e.g. corners), the first edge
    * encountered with a closest point will be returned after evaluating edges in
    * this order:
    * top, right, bottom, left (before applying the rectangle's rotation)
    */
  export function pointInRectangle(point: Point, rectangle: Rectangle): {
      intersects: boolean;
      closestPoint: Point;
      distance: number;
  };
  /**
    * Check if a point is inside a polygon
    *
    * Returns null if the polygon is invalid
    *
    * Also returns the closest point on the polygon edge and the distance to it
    *
    * If the point is inside the polygon, the distance will be negative
    */
  export function pointInPolygon(point: Point, polygon: Polygon): {
      intersects: boolean;
      closestPoint: Point;
      distance: number;
  } | null;
  /**
    * Check which grid cells a ray traverses
    *
    * Based on "A Fast Voxel Traversal Algorithm for Ray Tracing" by Amanatides
    * and Woo
    *
    * We can optionally limit the number of cells traversed by the ray, or set
    * maxCells to -1 to continue traversing until the ray exits the grid (or until
    * we hit the hard limit of 10000 cells).
    */
  export function rayTraverseGrid(ray: Ray, cellSize: number, gridTopLeft: vec2, gridBottomRight: vec2, maxCells?: number): {
      cells: Point[];
  };
  /**
    * Check if two rays intersect
    */
  export function rayIntersectsRay(rayA: Ray, rayB: Ray): {
      intersects: boolean;
      intersectionPoint?: Point;
  };
  /**
    * Check if a ray intersects a line segment
    */
  export function rayIntersectsLine(ray: Ray, line: Line): {
      intersects: boolean;
      intersectionPoint?: Point;
  };
  /**
    * Check if a ray intersects a circle
    */
  export function rayIntersectsCircle(ray: Ray, circle: Circle): {
      intersects: boolean;
      intersectionPoints?: Point[];
  };
  /**
    * Check if a ray intersects a rectangle
    */
  export function rayIntersectsRectangle(ray: Ray, rectangle: Rectangle): {
      intersects: boolean;
      intersectionPoints?: Point[];
  };
  /**
    * Check if a ray intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function rayIntersectsPolygon(ray: Ray, polygon: Polygon): {
      intersects: boolean;
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if a line segment intersects a ray
    */
  export function lineIntersectsRay(line: Line, ray: Ray): {
      intersects: boolean;
      intersectionPoint?: Point;
  };
  /**
    * Check if two line segments intersect
    */
  export function lineIntersectsLine(lineA: Line, lineB: Line): {
      intersects: boolean;
      intersectionPoint?: Point;
  };
  /**
    * Check if a line segment intersects a circle
    */
  export function lineIntersectsCircle(line: Line, circle: Circle): {
      intersects: boolean;
      intersectionPoints?: Point[];
  };
  /**
    * Check if a line segment intersects a rectangle
    */
  export function lineIntersectsRectangle(line: Line, rectangle: Rectangle): {
      intersects: boolean;
      intersectionPoints?: Point[];
  };
  /**
    * Check if a line segment intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function lineIntersectsPolygon(line: Line, polygon: Polygon): {
      intersects: boolean;
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if two circles intersect
    */
  export function circleIntersectsCircle(circleA: Circle, circleB: Circle): {
      intersects: boolean;
      intersectionPoints?: Point[];
      minimumSeparation?: vec2;
  };
  /**
    * Check if a circle intersects a rectangle
    */
  export function circleIntersectsRectangle(circle: Circle, rectangle: Rectangle): {
      intersects: boolean;
      intersectionPoints?: Point[];
      minimumSeparation?: vec2;
  };
  /**
    * Check if a circle intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function circleIntersectsPolygon(circle: Circle, polygon: Polygon, options?: {
      findMinimumSeparation?: boolean;
  }): {
      intersects: boolean;
      intersectionPoints?: Point[];
      minimumSeparation?: vec2;
  } | null;
  /**
    * Check if two rectangles intersect
    */
  export function rectangleIntersectsRectangle(rectangleA: Rectangle, rectangleB: Rectangle): {
      intersects: boolean;
      intersectionPoints?: Point[];
      minimumSeparation?: vec2;
  };
  /**
    * Check if a rectangle intersects a polygon
    *
    * Returns null if the polygon is invalid
    */
  export function rectangleIntersectsPolygon(rectangle: Rectangle, polygon: Polygon): {
      intersects: boolean;
      intersectionPoints?: Point[];
  } | null;
  /**
    * Check if two polygons intersect
    *
    * Returns null if either polygon is invalid
    */
  export function polygonIntersectsPolygon(polygonA: Polygon, polygonB: Polygon): {
      intersects: boolean;
      intersectionPoints?: Point[];
  } | null;
}

declare module '@basementuniverse/intersection-helpers/src/3d' {
  import { vec3 } from '@basementuniverse/vec';
  import { Line, Point, Ray } from '@basementuniverse/intersection-helpers/src/3d/types';
  export * from '@basementuniverse/intersection-helpers/src/3d/types';
  /**
    * Calculate the distance between two points in 3D space
    *
    * @param a First point
    * @param b Second point
    * @returns Distance between the two points
    */
  export function distance(a: Point, b: Point): number;
  /**
    * Calculate the angle between two vectors in 3D space
    *
    * @param a First vector
    * @param b Second vector
    * @returns Angle in radians
    */
  export function angleBetween(a: vec3, b: vec3): number;
  /**
    * Convert a line segment to a ray
    */
  export function lineToRay(line: Line): Ray;
  /**
    * Convert a ray to a line segment
    */
  export function rayToLine(ray: Ray, length?: number): Line;
}

declare module '@basementuniverse/intersection-helpers/src/utilities' {
  import { vec2, vec3 } from '@basementuniverse/vec';
  import { Interval } from '@basementuniverse/intersection-helpers/src/utilities/types';
  /**
    * Check if a vector is almost zero
    */
  export function vectorAlmostZero(v: vec2): boolean;
  export function vectorAlmostZero(v: vec3): boolean;
  /**
    * Check if two vectors are almost equal
    */
  export function vectorsAlmostEqual(a: vec2, b: vec2): boolean;
  export function vectorsAlmostEqual(a: vec3, b: vec3): boolean;
  /**
    * Check if a value is within a specified interval
    */
  export function valueInInterval(value: number, interval: Interval): boolean;
  /**
    * Check if two intervals (a1, a2) and (b1, b2) overlap
    */
  export function intervalsOverlap(a: Interval, b: Interval): boolean;
  /**
    * Get the overlapping part of two intervals (a1, a2) and (b1, b2)
    *
    * If the intervals do not overlap, return null
    */
  export function overlapInterval(a: Interval, b: Interval): Interval | null;
}

declare module '@basementuniverse/intersection-helpers/src/2d/types' {
  import { vec2 } from '@basementuniverse/vec';
  /**
    * A point in 2D space
    */
  export type Point = vec2;
  /**
    * Type guard to check if a value is a Point
    */
  export function isPoint(value: any): value is Point;
  /**
    * A ray that extends infinitely in one direction
    */
  export type Ray = {
      origin: Point;
      direction: vec2;
  };
  /**
    * Check if a value is a Ray
    */
  export function isRay(value: any): value is Ray;
  /**
    * A line segment defined by two endpoints
    */
  export type Line = {
      start: Point;
      end: Point;
  };
  /**
    * Check if a value is a Line
    */
  export function isLine(value: any): value is Line;
  /**
    * A circle defined by its center and radius
    */
  export type Circle = {
      position: Point;
      radius: number;
  };
  /**
    * Check if a value is a Circle
    */
  export function isCircle(value: any): value is Circle;
  /**
    * An axis-aligned bounding box (AABB) defined by the position of its top-left
    * corner and its width and height
    */
  export type AABB = {
      position: Point;
      size: vec2;
  };
  /**
    * Check if a value is an AABB
    */
  export function isAABB(value: any): value is AABB;
  /**
    * A rectangle defined by the position of its center, side lengths, and
    * optional rotation
    *
    * Rotation is in radians and is applied around the center of the rectangle
    */
  export type Rectangle = {
      position: Point;
      size: vec2;
      rotation?: number;
  };
  /**
    * Check if a value is a Rectangle
    */
  export function isRectangle(value: any): value is Rectangle;
  /**
    * A polygon defined by its vertices
    *
    * Vertices can be ordered in clockwise or counter-clockwise winding order
    */
  export type Polygon = {
      vertices: Point[];
  };
  /**
    * Check if a value is a Polygon
    */
  export function isPolygon(value: any): value is Polygon;
}

declare module '@basementuniverse/intersection-helpers/src/3d/types' {
  import { vec3 } from '@basementuniverse/vec';
  /**
    * A point in 3D space
    */
  export type Point = vec3;
  /**
    * Type guard to check if a value is a Point
    */
  export function isPoint(value: any): value is Point;
  /**
    * A ray that extends infinitely in one direction
    */
  export type Ray = {
      origin: Point;
      direction: vec3;
  };
  /**
    * Check if a value is a Ray
    */
  export function isRay(value: any): value is Ray;
  /**
    * A line segment defined by two endpoints
    */
  export type Line = {
      start: Point;
      end: Point;
  };
  /**
    * Check if a value is a Line
    */
  export function isLine(value: any): value is Line;
  /**
    * A sphere defined by its center and radius
    */
  export type Sphere = {
      position: Point;
      radius: number;
  };
  /**
    * Check if a value is a Sphere
    */
  export function isSphere(value: any): value is Sphere;
  /**
    * An axis-aligned bounding box (AABB) defined by the position of its top-left
    * corner and its width, height, and depth
    */
  export type AABB = {
      position: Point;
      size: vec3;
  };
  /**
    * Check if a value is an AABB
    */
  export function isAABB(value: any): value is AABB;
  /**
    * A cuboid defined by the position of its center, side lengths, and
    * optional rotation
    *
    * Rotation is represented as Euler angles measured in radians and is applied
    * around the center of the rectangle
    */
  export type Cuboid = {
      position: Point;
      size: vec3;
      rotation?: vec3;
  };
  /**
    * Check if a value is a Cuboid
    */
  export function isCuboid(value: any): value is Cuboid;
  /**
    * A plane defined by a point on the plane and a normal vector
    */
  export type Plane = {
      point: Point;
      normal: vec3;
  };
  /**
    * Check if a value is a Plane
    */
  export function isPlane(value: any): value is Plane;
  /**
    * A polygon (triangle in 3D space) defined by three vertices
    */
  export type Polygon = {
      vertices: [Point, Point, Point];
  };
  /**
    * Check if a value is a Polygon
    */
  export function isPolygon(value: any): value is Polygon;
}

declare module '@basementuniverse/intersection-helpers/src/utilities/types' {
  import { vec2, vec3 } from '@basementuniverse/vec';
  /**
    * A numeric interval with optional inclusivity
    */
  export type Interval = {
      min: number;
      minInclusive?: boolean;
      max: number;
      maxInclusive?: boolean;
  };
  /**
    * Check if a value is a vec2
    */
  export function isVec2(value: any): value is vec2;
  /**
    * Check if a value is a vec3
    */
  export function isVec3(value: any): value is vec3;
}

