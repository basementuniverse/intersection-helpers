!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var s in n)("object"==typeof exports?exports:e)[s]=n[s]}}(this,(()=>{return e={395:e=>{const t=(e,t=0,n=1)=>e<t?t:e>n?n:e,n=e=>e>=0?e-Math.floor(e):e-Math.ceil(e),s=(e,t,n)=>e+(t-e)*n,r=(e=.5,t=.5,n=2)=>{let s=0;for(let e=n;e--;)s+=Math.random();return e+(s-n/2)/(n/2)*t},i=e=>{let t=1;for(let n=2;n<=e;n++)t*=n;return t},c=(e,t)=>1===t?e.map((e=>[e])):e.reduce(((n,s,r)=>[...n,...c(e.slice(0,r).concat(e.slice(r+1)),t-1).map((e=>[s,...e]))]),[]),o=(e,t)=>1===t?e.map((e=>[e])):e.reduce(((n,s,r)=>[...n,...o(e.slice(r+1),t-1).map((e=>[s,...e]))]),[]),a=(e,t)=>Array(t).fill(0).map(((t,n)=>e(n))),u=(e,t=".")=>Object.keys(e).reduce(((n,s)=>{if(e[s]instanceof Date)return{...n,[s]:e[s].toISOString()};if("object"!=typeof e[s]||!e[s])return{...n,[s]:e[s]};const r=u(e[s],t);return{...n,...Object.keys(r).reduce(((e,n)=>({...e,[`${s}${t}${n}`]:r[n]})),{})}}),{});e.exports={memoize:e=>{var t={};return function(...n){return t[n]??(t[n]=e.apply(this,n))}},floatEquals:(e,t,n=Number.EPSILON)=>Math.abs(e-t)<n,clamp:t,frac:n,round:(e,t=0)=>{const n=Math.pow(10,t);return Math.round(e*n+Number.EPSILON)/n},lerp:s,unlerp:(e,t,n)=>(n-e)/(t-e),blerp:(e,t,n,r,i,c)=>s(s(e,t,i),s(n,r,i),c),remap:(e,t,n,s,r)=>s+(e-t)*(r-s)/(n-t),smoothstep:(e,t,n)=>s(e,t,3*Math.pow(n,2)-2*Math.pow(n,3)),radians:e=>Math.PI/180*e,degrees:e=>180/Math.PI*e,randomBetween:(e,t)=>Math.random()*(t-e)+e,randomIntBetween:(e,t)=>Math.floor(Math.random()*(t-e+1))+e,cltRandom:r,cltRandomInt:(e,t)=>Math.floor(e+r(.5,.5,2)*(t+1-e)),weightedRandom:e=>{let t=e.reduce(((e,t)=>e+t),0),n=0;const s=Math.random()*t;for(;t>s;)t-=e[n++];return n-1},lerpArray:(e,r,i=s)=>{const c=r*(e.length-1),o=t(Math.trunc(c),0,e.length-1);return i(e[o]||0,e[o+1]||0,n(c))},dot:(e,t)=>e.reduce(((e,n,s)=>e+n*t[s]),0),factorial:i,npr:(e,t)=>i(e)/i(e-t),ncr:(e,t)=>i(e)/(i(t)*i(e-t)),permutations:c,combinations:o,cartesian:(...e)=>e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[...e,t]))))),[[]]),times:a,range:e=>a((e=>e),e),zip:(...e)=>a((t=>e.map((e=>e[t]))),Math.max(...e.map((e=>e.length)))),at:(e,t)=>e[t<0?e.length-Math.abs(t+1)%e.length-1:t%e.length],peek:e=>{if(e.length)return e[e.length-1]},ind:(e,t,n)=>e+t*n,pos:(e,t)=>[e%t,Math.floor(e/t)],chunk:(e,t)=>a((n=>e.slice(n*t,n*t+t)),Math.ceil(e.length/t)),shuffle:e=>e.slice().sort((()=>Math.random()-.5)),flat:u,unflat:(e,t=".")=>{let n,s,r,i,c={};for(r in e){for(s=r.split(t),n=c,i=0;i<s.length-1;i++)s[i]in n||(isFinite(s[i+1])?n[s[i]]=[]:n[s[i]]={}),n=n[s[i]];n[s[s.length-1]]=e[r]}return c},split:(e,t)=>{const n=[];let s=[];for(const r of e)t(r)?(s.length&&n.push(s),s=[r]):s.push(r);return n.push(s),n},pluck:(e,...t)=>t.reduce(((t,n)=>Object.assign(t,{[n]:e[n]})),{}),exclude:(e,...t)=>Object.fromEntries(Object.entries(e).filter((([e])=>!t.includes(e))))}},430:e=>{const t=(e,t)=>Array(t).fill(0).map(((t,n)=>e(n))),n=(e,t)=>e.reduce(((e,n,s)=>e+n*t[s]),0),s=e=>"object"==typeof e&&"x"in e&&"y"in e,r=e=>"object"==typeof e&&"x"in e&&"y"in e&&"z"in e,i=(e,t)=>e||t?s(e)?{x:e.x||0,y:e.y||0}:{x:e,y:t??e}:{x:0,y:0};i.components=e=>[e.x,e.y],i.fromComponents=e=>i(...e.slice(0,2)),i.ux=()=>i(1,0),i.uy=()=>i(0,1),i.add=(e,t)=>({x:e.x+(t.x??t),y:e.y+(t.y??t)}),i.sub=(e,t)=>({x:e.x-(t.x??t),y:e.y-(t.y??t)}),i.mul=(e,t)=>({x:e.x*(t.x??t),y:e.y*(t.y??t)}),i.scale=(e,t)=>i.mul(e,t),i.div=(e,t)=>({x:e.x/(t.x??t),y:e.y/(t.y??t)}),i.len=e=>Math.sqrt(e.x*e.x+e.y*e.y),i.manhattan=e=>Math.abs(e.x)+Math.abs(e.y),i.nor=e=>{let t=i.len(e);return t?{x:e.x/t,y:e.y/t}:i()},i.dot=(e,t)=>e.x*t.x+e.y*t.y,i.rot=(e,t)=>{let n=Math.sin(t),s=Math.cos(t);return{x:s*e.x-n*e.y,y:n*e.x+s*e.y}},i.rotf=(e,t)=>{switch(t){case 1:return i(e.y,-e.x);case-1:return i(-e.y,e.x);case 2:case-2:return i(-e.x,-e.y);default:return e}},i.cross=(e,t)=>e.x*t.y-e.y*t.x,i.eq=(e,t)=>e.x===t.x&&e.y===t.y,i.rad=e=>Math.atan2(e.y,e.x),i.cpy=e=>i(e),i.map=(e,t)=>({x:t(e.x,"x"),y:t(e.y,"y")}),i.str=(e,t=", ")=>`${e.x}${t}${e.y}`,i.swiz=(e,t="..")=>{const n=[];return t.split("").forEach(((t,s)=>{switch(t){case"x":case"u":n.push(e.x);break;case"y":case"v":n.push(e.y);break;case"X":case"U":n.push(-e.x);break;case"Y":case"V":n.push(-e.y);break;case"0":default:n.push(0);break;case"1":n.push(1);break;case".":n.push([e.x,e.y][s]??0)}})),n},i.polar=e=>({r:i.len(e),theta:Math.atan2(e.y,e.x)}),i.fromPolar=(e,t)=>i(e*Math.cos(t),e*Math.sin(t));const c=(e,t,n)=>e||t||n?r(e)?{x:e.x||0,y:e.y||0,z:e.z||0}:s(e)?{x:e.x||0,y:e.y||0,z:t||0}:{x:e,y:t??e,z:n??e}:{x:0,y:0,z:0};c.components=e=>[e.x,e.y,e.z],c.fromComponents=e=>c(...e.slice(0,3)),c.ux=()=>c(1,0,0),c.uy=()=>c(0,1,0),c.uz=()=>c(0,0,1),c.add=(e,t)=>({x:e.x+(t.x??t),y:e.y+(t.y??t),z:e.z+(t.z??t)}),c.sub=(e,t)=>({x:e.x-(t.x??t),y:e.y-(t.y??t),z:e.z-(t.z??t)}),c.mul=(e,t)=>({x:e.x*(t.x??t),y:e.y*(t.y??t),z:e.z*(t.z??t)}),c.scale=(e,t)=>c.mul(e,t),c.div=(e,t)=>({x:e.x/(t.x??t),y:e.y/(t.y??t),z:e.z/(t.z??t)}),c.len=e=>Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z),c.manhattan=e=>Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z),c.nor=e=>{let t=c.len(e);return t?{x:e.x/t,y:e.y/t,z:e.z/t}:c()},c.dot=(e,t)=>e.x*t.x+e.y*t.y+e.z*t.z,c.rot=(e,t)=>c(c.dot(c.fromComponents(o.row(t,1)),e),c.dot(c.fromComponents(o.row(t,2)),e),c.dot(c.fromComponents(o.row(t,3)),e)),c.rotx=(e,t)=>c(e.x,e.y*Math.cos(t)-e.z*Math.sin(t),e.y*Math.sin(t)+e.z*Math.cos(t)),c.roty=(e,t)=>c(e.x*Math.cos(t)+e.z*Math.sin(t),e.y,-e.x*Math.sin(t)+e.z*Math.cos(t)),c.rotz=(e,t)=>c(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),e.z),c.rotq=(e,t)=>{if(4!==t.length)return c();const n=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]);if(0===n)return c();const s=[t[0]/n,t[1]/n,t[2]/n,t[3]/n],r=c(...s.slice(0,3)),i=s[3];return c.add(c.add(c.mul(r,2*c.dot(r,e)),c.mul(e,i*i-c.dot(r,r))),c.mul(c.cross(r,e),2*i))},c.rota=(e,t)=>c.rotz(c.roty(c.rotx(e,t.x),t.y),t.z),c.cross=(e,t)=>c(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x),c.eq=(e,t)=>e.x===t.x&&e.y===t.y&&e.z===t.z,c.radx=e=>Math.atan2(e.z,e.y),c.rady=e=>Math.atan2(e.x,e.y),c.radz=e=>Math.atan2(e.y,e.z),c.cpy=e=>c(e),c.map=(e,t)=>({x:t(e.x,"x"),y:t(e.y,"y"),z:t(e.z,"z")}),c.str=(e,t=", ")=>`${e.x}${t}${e.y}${t}${e.z}`,c.swiz=(e,t="...")=>{const n=[];return t.split("").forEach(((t,s)=>{switch(t){case"x":case"u":case"r":n.push(e.x);break;case"y":case"v":case"g":n.push(e.y);break;case"z":case"w":case"b":n.push(e.z);break;case"X":case"U":case"R":n.push(-e.x);break;case"Y":case"V":case"G":n.push(-e.y);break;case"Z":case"W":case"B":n.push(-e.z);break;case"0":default:n.push(0);break;case"1":n.push(1);break;case".":n.push([e.x,e.y,e.z][s]??0)}})),n},c.polar=e=>{let t=c.len(e);return{r:t,theta:Math.acos(e.y/t),phi:Math.atan2(e.z,e.x)}},c.fromPolar=(e,t,n)=>{const s=Math.sin(t);return c(e*s*Math.cos(n),e*Math.cos(t),e*s*Math.sin(n))};const o=(e=4,t=4,n=[])=>({m:e,n:t,entries:n.concat(Array(e*t).fill(0)).slice(0,e*t)});o.identity=e=>o(e,e,Array(e*e).fill(0).map(((t,n)=>+(Math.floor(n/e)===n%e)))),o.get=(e,t,n)=>e.entries[n-1+(t-1)*e.n],o.set=(e,t,n,s)=>{e.entries[n-1+(t-1)*e.n]=s},o.row=(e,t)=>{const n=(t-1)*e.n;return e.entries.slice(n,n+e.n)},o.col=(e,n)=>t((t=>o.get(e,t+1,n)),e.m),o.add=(e,t)=>e.m===t.m&&e.n===t.n&&o.map(e,((e,n)=>e+t.entries[n])),o.sub=(e,t)=>e.m===t.m&&e.n===t.n&&o.map(e,((e,n)=>e-t.entries[n])),o.mul=(e,t)=>{if(e.n!==t.m)return!1;const s=o(e.m,t.n);for(let r=1;r<=e.m;r++)for(let i=1;i<=t.n;i++)o.set(s,r,i,n(o.row(e,r),o.col(t,i)));return s},o.mulv=(e,t)=>{let a,u,v;if(r(t)?(u=c.components(t),a=3,v=c.fromComponents):s(t)?(u=i.components(t),a=2,v=i.fromComponents):(u=t,a=t.length??0,v=e=>e),e.n!==a)return!1;const l=[];for(let t=1;t<=e.m;t++)l.push(n(o.row(e,t),u));return v(l)},o.scale=(e,t)=>o.map(e,(e=>e*t)),o.trans=e=>o(e.n,e.m,t((t=>o.col(e,t+1)),e.n).flat()),o.minor=(e,t,n)=>{if(e.m!==e.n)return!1;const s=[];for(let r=1;r<=e.m;r++)if(r!==t)for(let t=1;t<=e.n;t++)t!==n&&s.push(o.get(e,r,t));return o(e.m-1,e.n-1,s)},o.det=e=>{if(e.m!==e.n)return!1;if(1===e.m)return e.entries[0];if(2===e.m)return e.entries[0]*e.entries[3]-e.entries[1]*e.entries[2];let t=0,n=1;for(let s=1;s<=e.n;s++)t+=n*e.entries[s-1]*o.det(o.minor(e,1,s)),n*=-1;return t},o.nor=e=>{if(e.m!==e.n)return!1;const t=o.det(e);return o.map(e,(e=>e*t))},o.adj=e=>{const t=o(e.m,e.n);for(let n=1;n<=e.m;n++)for(let s=1;s<=e.n;s++)o.set(t,n,s,o.det(o.minor(e,n,s)));const n=o.map(t,((e,t)=>e*(t%2?-1:1)));return o.trans(n)},o.inv=e=>{if(e.m!==e.n)return!1;const t=o.det(e);return 0!==t&&o.scale(o.adj(e),1/t)},o.eq=(e,t)=>e.m===t.m&&e.n===t.n&&o.str(e)===o.str(t),o.cpy=e=>o(e.m,e.n,[...e.entries]),o.map=(e,t)=>o(e.m,e.n,e.entries.map(t)),o.str=(e,n=", ",s="\n")=>((e,n)=>t((t=>e.slice(t*n,t*n+n)),Math.ceil(e.length/n)))(e.entries,e.n).map((e=>e.join(n))).join(s),e.exports={vec2:i,vec3:c,mat:o}},82:function(e,t,n){"use strict";var s,r=this&&this.__createBinding||(Object.create?function(e,t,n,s){void 0===s&&(s=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,s,r)}:function(e,t,n,s){void 0===s&&(s=n),e[s]=t[n]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),c=this&&this.__importStar||(s=function(e){return s=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n);return t},s(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n=s(e),c=0;c<n.length;c++)"default"!==n[c]&&r(t,e,n[c]);return i(t,e),t}),o=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),t.distance=function(e,t){return u.vec3.len(u.vec3.sub(e,t))},t.angle=function(e,t){if((0,v.vectorsAlmostEqual)(e,t))return(0,u.vec3)();let n=u.vec3.radx(u.vec3.sub(t,e))%(2*Math.PI);n<0&&(n+=2*Math.PI);let s=u.vec3.rady(u.vec3.sub(t,e))%(2*Math.PI);s<0&&(s+=2*Math.PI);let r=u.vec3.radz(u.vec3.sub(t,e))%(2*Math.PI);return r<0&&(r+=2*Math.PI),(0,u.vec3)(n,s,r)},t.angleBetween=function(e,t){let n=(0,d.isRay)(e)?h(e,1):e,s=(0,d.isRay)(t)?h(t,1):t;if((0,v.vectorAlmostZero)(u.vec3.sub(n.start,n.end))||(0,v.vectorAlmostZero)(u.vec3.sub(s.start,s.end)))return 0;const r=u.vec3.nor(u.vec3.sub(n.end,n.start)),i=u.vec3.nor(u.vec3.sub(s.end,s.start)),c=(0,a.clamp)(u.vec3.dot(r,i),-1,1),o=Math.acos(c);return o<0?o+2*Math.PI:o},t.pointsAreCollinear=function(e,t,n){const s=u.vec3.sub(t,e),r=u.vec3.sub(n,e),i=u.vec3.cross(s,r);return u.vec3.len(i)<l.EPSILON},t.lineToRay=function(e){return{origin:e.start,direction:u.vec3.nor(u.vec3.sub(e.end,e.start))}},t.rayToLine=h,t.aabb=function(e){if((0,d.isLine)(e))return{position:(0,u.vec3)(Math.min(e.start.x,e.end.y),Math.min(e.start.y,e.end.y),Math.min(e.start.z,e.end.z)),size:(0,u.vec3)(Math.abs(e.start.x-e.end.x),Math.abs(e.start.y-e.end.y),Math.abs(e.start.z-e.end.z))};if((0,d.isSphere)(e))return{position:e.position,size:(0,u.vec3)(2*e.radius)};if((0,d.isCuboid)(e)){const t=m(e),n=(0,u.vec3)(Math.min(...t.map((e=>e.x))),Math.min(...t.map((e=>e.y))),Math.min(...t.map((e=>e.z))));return{position:n,size:(0,u.vec3)(Math.max(...t.map((e=>e.x)))-n.x,Math.max(...t.map((e=>e.y)))-n.y,Math.max(...t.map((e=>e.z)))-n.z)}}if((0,d.isMesh)(e)||(0,d.isPolygon)(e)){const t=(0,u.vec3)(Math.min(...e.vertices.map((e=>e.x))),Math.min(...e.vertices.map((e=>e.y))),Math.min(...e.vertices.map((e=>e.z))));return{position:t,size:(0,u.vec3)(Math.max(...e.vertices.map((e=>e.x)))-t.x,Math.max(...e.vertices.map((e=>e.y)))-t.y,Math.max(...e.vertices.map((e=>e.z)))-t.z)}}return null},t.aabbToCuboid=function(e){return{position:u.vec3.add(e.position,u.vec3.div(e.size,2)),size:e.size,rotation:(0,u.vec3)(0,0,0)}},t.aabbsOverlap=function(e,t){const n=(0,v.overlapInterval)({min:e.position.x,max:e.position.x+e.size.x},{min:t.position.x,max:t.position.x+t.size.x}),s=(0,v.overlapInterval)({min:e.position.y,max:e.position.y+e.size.y},{min:t.position.y,max:t.position.y+t.size.y}),r=(0,v.overlapInterval)({min:e.position.z,max:e.position.z+e.size.z},{min:t.position.z,max:t.position.z+t.size.z});return n&&s&&r?{intersects:!0,overlap:{position:(0,u.vec3)(n.min,s.min,r.min),size:(0,u.vec3)(n.max-n.min,s.max-s.min,r.max-r.min)}}:{intersects:!1}},t.pointInAABB=function(e,t){const{position:n,size:s}=t,r=n,i=u.vec3.add(n,s),c=(0,v.valueInInterval)(e.x,{min:r.x,max:i.x})&&(0,v.valueInInterval)(e.y,{min:r.y,max:i.y})&&(0,v.valueInInterval)(e.z,{min:r.z,max:i.z});let o;if(c){const t=[{x:r.x,y:e.y,z:e.z,d:Math.abs(e.x-r.x)},{x:i.x,y:e.y,z:e.z,d:Math.abs(e.x-i.x)},{x:e.x,y:r.y,z:e.z,d:Math.abs(e.y-r.y)},{x:e.x,y:i.y,z:e.z,d:Math.abs(e.y-i.y)},{x:e.x,y:e.y,z:r.z,d:Math.abs(e.z-r.z)},{x:e.x,y:e.y,z:i.z,d:Math.abs(e.z-i.z)}].reduce(((e,t)=>e.d<t.d?e:t));o=(0,u.vec3)(t.x,t.y,t.z)}else o=(0,u.vec3)((0,a.clamp)(e.x,r.x,i.x),(0,a.clamp)(e.y,r.y,i.y),(0,a.clamp)(e.z,r.z,i.z));const l=u.vec3.len(u.vec3.sub(e,o));return{intersects:c,closestPoint:o,distance:c?-l:l}},t.cuboidIsRotated=f,t.cuboidVertices=m,t.cuboidToPolygons=p,t.verticesToEdges=y,t.polygonIsValid=x,t.polygonWindingOrder=function(e,t){if(!x(e))return null;const[n,s,r]=e.vertices,i=(null==t?void 0:t.handedness)||"right",c=u.vec3.sub(s,n),o=u.vec3.sub(r,n),a=u.vec3.cross(c,o);if((0,v.vectorAlmostZero)(a))return null;if(null==t?void 0:t.normal){const e=u.vec3.dot(u.vec3.nor(a),u.vec3.nor(t.normal));return Math.abs(e)<l.EPSILON?null:"right"===i?e>0?"counter-clockwise":"clockwise":e>0?"clockwise":"counter-clockwise"}return Math.abs(a.z)<l.EPSILON?null:"right"===i?a.z>0?"counter-clockwise":"clockwise":a.z>0?"clockwise":"counter-clockwise"},t.polygonArea=function(e){if(!x(e))return null;const[t,n,s]=e.vertices;return Math.abs(t.x*(n.y-n.x)*t.y+n.x*(s.y-s.x)*n.y+s.x*(t.y-t.x)*s.y)/2},t.polygonCentroid=b,t.polygonToPlane=function(e){if(!x(e))return null;const[t,n,s]=e.vertices,r=u.vec3.sub(n,t),i=u.vec3.sub(s,t),c=u.vec3.nor(u.vec3.cross(r,i));return{point:b(e),normal:c}},t.polygonsToMesh=function(e){if(0===e.length)return{vertices:[],indices:[]};const t=new Map,n=[];return e.forEach(((e,s)=>{if(!x(e))throw new Error(`Invalid polygon at index ${s}`);e.vertices.forEach((e=>{const s=`${e.x},${e.y},${e.z}`;t.has(s)||t.set(s,e);const r=Array.from(t.keys()).indexOf(s);n.push(r)}))})),{vertices:Array.from(t.values()),indices:n}},t.meshToPolygons=M,t.meshToEdges=function(e){if(e.indices.length%2!=0)throw new Error("Mesh indices must be a multiple of 2 to form edges");const t=[];for(let n=0;n<e.indices.length;n+=2){const s=e.indices[n],r=e.indices[n+1];if(s>=e.vertices.length||r>=e.vertices.length)throw new Error("Mesh indices out of bounds");t.push({start:e.vertices[s],end:e.vertices[r]})}return t},t.meshCentroid=function(e){return u.vec3.div(e.vertices.reduce(((e,t)=>u.vec3.add(e,t)),(0,u.vec3)()),e.vertices.length)},t.meshIsWatertight=function(e){const t=new Map;for(let n=0;n<e.indices.length;n+=3){const s=e.indices[n],r=e.indices[n+1],i=e.indices[n+2];[[Math.min(s,r),Math.max(s,r)],[Math.min(r,i),Math.max(r,i)],[Math.min(i,s),Math.max(i,s)]].forEach((([e,n])=>{const s=`${e},${n}`;t.set(s,(t.get(s)||0)+1)}))}return Array.from(t.values()).every((e=>2===e))},t.pointOnRay=function(e,t){const n=u.vec3.sub(e,t.origin),s=u.vec3.nor(t.direction),r=u.vec3.dot(n,s),i=u.vec3.add(t.origin,u.vec3.mul(s,Math.max(0,r))),c=u.vec3.len(u.vec3.sub(e,i));return{intersects:c<l.EPSILON&&r>=0,closestPoint:i,distance:c}},t.pointOnLine=z,t.pointInSphere=function(e,t){const n=u.vec3.sub(e,t.position),s=u.vec3.len(n),r=s<=t.radius,i=r?-(t.radius-s):s-t.radius;return{intersects:r,closestPoint:u.vec3.add(t.position,u.vec3.mul(u.vec3.nor(n),t.radius)),distance:i}},t.pointInCuboid=P,t.pointOnPolygon=g,t.rayTraverseGrid=function(e,t,n,s,r=-1){if(t<=0)return{cells:[]};if((r=(0,a.clamp)(-1===r?1e4:r,0,1e4))<=0)return{cells:[]};n=u.vec3.map(n,Math.floor),s=u.vec3.map(s,Math.ceil);const i=u.vec3.nor(e.direction);if((0,v.vectorAlmostZero)(i))return{cells:[]};const c=[];let o=u.vec3.map(u.vec3.div(u.vec3.sub(e.origin,n),t),Math.floor);const d=u.vec3.sub(s,n);if(o.x<0||o.x>=d.x||o.y<0||o.y>=d.y||o.z<0||o.z>=d.z){const r=E(e,{position:u.vec3.add(n,u.vec3.div(u.vec3.sub(s,n),2)),size:u.vec3.sub(s,n)});if(!r.intersects||!r.intersectionPoints)return{cells:c};const i=r.intersectionPoints[0];if(o=u.vec3.map(u.vec3.div(u.vec3.sub(i,n),t),Math.floor),o.x<0||o.x>=d.x||o.y<0||o.y>=d.y||o.z<0||o.z>=d.z)return{cells:c}}const h=Math.sign(i.x),f=Math.sign(i.y),m=Math.sign(i.z),p={x:0!==i.x?Math.abs(t/i.x):1/0,y:0!==i.y?Math.abs(t/i.y):1/0,z:0!==i.z?Math.abs(t/i.z):1/0},y=(0,u.vec3)(n.x+(o.x+(h>0?1:0))*t,n.y+(o.y+(f>0?1:0))*t,n.z+(o.z+(m>0?1:0))*t),x={x:0!==i.x?Math.abs((y.x-e.origin.x)/i.x):1/0,y:0!==i.y?Math.abs((y.y-e.origin.y)/i.y):1/0,z:0!==i.z?Math.abs((y.z-e.origin.z)/i.z):1/0};Math.abs(e.origin.x-y.x)<l.EPSILON&&(x.x=p.x),Math.abs(e.origin.y-y.y)<l.EPSILON&&(x.y=p.y),Math.abs(e.origin.z-y.z)<l.EPSILON&&(x.z=p.z),c.push((0,u.vec3)(o.x,o.y,o.z));let b=1;for(;b<r&&o.x>=0&&o.x<d.x&&o.y>=0&&o.y<d.y&&o.z>=0&&o.z<d.z&&(x.x<x.y&&x.x<x.z?(x.x+=p.x,o.x+=h):x.y<x.z?(x.y+=p.y,o.y+=f):(x.z+=p.z,o.z+=m),!(o.x<0||o.x>=d.x||o.y<0||o.y>=d.y||o.z<0||o.z>=d.z));)c.push((0,u.vec3)(o.x,o.y,o.z)),b++;return{cells:c}},t.rayIntersectsRay=function(e,t){const n=u.vec3.nor(e.direction),s=u.vec3.nor(t.direction);if((0,v.vectorAlmostZero)(n)||(0,v.vectorAlmostZero)(s))return{intersects:!1};const r=u.vec3.sub(t.origin,e.origin),i=u.vec3.cross(n,s),c=u.vec3.dot(i,i);if(c<l.EPSILON){const t=u.vec3.cross(r,n);if(u.vec3.len(t)<l.EPSILON){const t=u.vec3.dot(r,n);if(t>=0)return{intersects:!0,intersectionPoint:u.vec3.add(e.origin,u.vec3.mul(n,t))}}return{intersects:!1}}const o=u.vec3.dot(r,u.vec3.cross(s,i))/c,a=u.vec3.dot(r,u.vec3.cross(n,i))/c;if(o<0||a<0)return{intersects:!1};const d=u.vec3.add(e.origin,u.vec3.mul(n,o)),h=u.vec3.add(t.origin,u.vec3.mul(s,a));return u.vec3.len(u.vec3.sub(d,h))<l.EPSILON?{intersects:!0,intersectionPoint:u.vec3.add(d,u.vec3.mul(u.vec3.sub(h,d),.5))}:{intersects:!1}},t.rayIntersectsLine=I,t.rayIntersectsSphere=function(e,t){const n=u.vec3.nor(e.direction),s=u.vec3.sub(t.position,e.origin),r=u.vec3.dot(n,n),i=2*u.vec3.dot(n,u.vec3.mul(s,-1)),c=i*i-4*r*(u.vec3.dot(s,s)-t.radius*t.radius);if(c<-l.EPSILON)return{intersects:!1};if(Math.abs(c)<l.EPSILON){const t=-i/(2*r);return t>=0?{intersects:!0,intersectionPoints:[u.vec3.add(e.origin,u.vec3.mul(n,t))]}:{intersects:!1}}const o=Math.sqrt(c),a=(-i-o)/(2*r),v=(-i+o)/(2*r);if(v<0)return{intersects:!1};const d=[];return a>=0&&d.push(u.vec3.add(e.origin,u.vec3.mul(n,a))),v>=0&&d.push(u.vec3.add(e.origin,u.vec3.mul(n,v))),{intersects:d.length>0,intersectionPoints:d.length>0?d:void 0}},t.rayIntersectsPlane=O,t.rayIntersectsCuboid=E,t.rayIntersectsPolygon=S,t.rayIntersectsMesh=function(e,t){const n=M(t),s=[];return n.forEach((t=>{const n=S(e,t);n&&n.intersects&&s.push(n.intersectionPoint)})),{intersects:s.length>0,intersectionPoints:s.length>0?s:void 0}},t.lineIntersectsRay=function(e,t){return I(t,e)},t.lineIntersectsLine=L,t.lineIntersectsSphere=N,t.lineIntersectsPlane=w,t.lineIntersectsCuboid=function(e,t){const n=u.vec3.sub(e.end,e.start),s=u.vec3.len(n);if(s<l.EPSILON){const n=P(e.start,t);return{intersects:n.intersects,intersectionPoints:n.intersects?[e.start]:void 0}}const r=u.vec3.div(n,s),{position:i,size:c,rotation:o=(0,u.vec3)()}=t;let a=u.vec3.sub(e.start,i),v=r;if(f(t)){const e=u.vec3.mul(o,-1);a=u.vec3.rota(a,e),v=u.vec3.rota(v,e)}const d=u.vec3.div(c,2),h=u.vec3.div(u.vec3.sub(u.vec3.mul(d,-1),a),v),m=u.vec3.div(u.vec3.sub(d,a),v),p=(0,u.vec3)(Math.min(h.x,m.x),Math.min(h.y,m.y),Math.min(h.z,m.z)),y=(0,u.vec3)(Math.max(h.x,m.x),Math.max(h.y,m.y),Math.max(h.z,m.z)),x=Math.max(p.x,p.y,p.z),b=Math.min(y.x,y.y,y.z);if(x>b||b<0||x>s)return{intersects:!1};const M=[];if(x>=0&&x<=s){let e=u.vec3.add(a,u.vec3.mul(v,x));f(t)&&(e=u.vec3.rota(e,o)),M.push(u.vec3.add(i,e))}if(b>x&&b>=0&&b<=s){let e=u.vec3.add(a,u.vec3.mul(v,b));f(t)&&(e=u.vec3.rota(e,o)),M.push(u.vec3.add(i,e))}return{intersects:M.length>0,intersectionPoints:M.length>0?M:void 0}},t.lineIntersectsPolygon=j,t.lineIntersectsMesh=function(e,t){const n=M(t),s=[];return n.forEach((t=>{const n=j(e,t);n&&n.intersects&&s.push(n.intersectionPoint)})),{intersects:s.length>0,intersectionPoints:s.length>0?s:void 0}},t.sphereIntersectsSphere=function(e,t){const n=u.vec3.sub(t.position,e.position),s=u.vec3.len(n),r=e.radius+t.radius;if(s>r)return{intersects:!1};if(s<l.EPSILON)return{intersects:!0,intersectionPoint:e.position,penetrationDepth:r,normal:(0,u.vec3)(1,0,0),contactPoints:{sphereA:u.vec3.add(e.position,(0,u.vec3)(e.radius,0,0)),sphereB:u.vec3.add(t.position,(0,u.vec3)(t.radius,0,0))}};const i=u.vec3.nor(n),c=r-s;return{intersects:!0,intersectionPoint:u.vec3.add(e.position,u.vec3.mul(i,e.radius+c/2)),penetrationDepth:c,normal:i,contactPoints:{sphereA:u.vec3.add(e.position,u.vec3.mul(i,e.radius)),sphereB:u.vec3.add(t.position,u.vec3.mul(i,-t.radius))}}},t.sphereIntersectsPlane=A,t.sphereIntersectsCuboid=function(e,t){const{position:n,size:s,rotation:r=(0,u.vec3)()}=t,i=u.vec3.div(s,2);let c=u.vec3.sub(e.position,n);f(t)&&(c=u.vec3.rota(c,u.vec3.mul(r,-1)));let o=(0,u.vec3)((0,a.clamp)(c.x,-i.x,i.x),(0,a.clamp)(c.y,-i.y,i.y),(0,a.clamp)(c.z,-i.z,i.z));f(t)&&(o=u.vec3.rota(o,r)),o=u.vec3.add(o,n);const v=u.vec3.sub(e.position,o),d=u.vec3.len(v);if(d>e.radius)return{intersects:!1};if(d<l.EPSILON){let t=u.vec3.nor(u.vec3.sub(e.position,n));const s=e.radius;return{intersects:!0,intersectionPoint:e.position,penetrationDepth:s,normal:t,contactPoint:o}}const h=u.vec3.nor(v),m=e.radius-d;return{intersects:!0,intersectionPoint:u.vec3.add(o,u.vec3.mul(h,m/2)),penetrationDepth:m,normal:h,contactPoint:o}},t.sphereIntersectsPolygon=_,t.sphereIntersectsMesh=function(e,t){const n=M(t);let s=!1;const r=[],i=[];return n.forEach((t=>{const n=_(e,t);n&&n.intersects&&(s=!0,r.push(n.intersectionPoint),n.polygonIntersectionPoints&&i.push(...n.polygonIntersectionPoints))})),{intersects:s,intersectionPoints:r.length>0?r:void 0,polygonIntersectionPoints:i.length>0?i:void 0}},t.planeIntersectsPlane=k,t.planeIntersectsMesh=function(e,t){return T(t,e)},t.cuboidIntersectsCuboid=function(e,t){const{position:n,size:s,rotation:r=(0,u.vec3)()}=e,{position:i,size:c,rotation:o=(0,u.vec3)()}=t,a=u.vec3.div(s,2),v=u.vec3.div(c,2),d=f(e)?C(r):null,h=f(t)?C(o):null,m=q(d),p=q(h),y=u.vec3.sub(i,n),x=[...m,...p,...V(m,p)];let b=1/0,M=null;for(const e of x){const t=u.vec3.len(e);if(t<l.EPSILON)continue;const n=u.vec3.div(e,t),s=u.vec3.dot(y,n),r=$(a,d,n)+$(v,h,n)-Math.abs(s);if(r<=0)return{intersects:!1};r<b&&(b=r,M=n)}if(!M)return{intersects:!0};const z=u.vec3.dot(y,M)<0?u.vec3.mul(M,-1):M,P=D(e,z),g=D(t,u.vec3.mul(z,-1));return{intersects:!0,intersectionPoint:u.vec3.add(P,u.vec3.mul(u.vec3.sub(g,P),.5)),penetrationDepth:b,normal:z,contactPoints:{cuboidA:P,cuboidB:g}}},t.cuboidIntersectsPlane=function(e,t){const n=p(e),s=[],r=u.vec3.nor(t.normal);let i,c=-1/0,o=1/0;m(e).forEach((e=>{const n=u.vec3.dot(u.vec3.sub(e,t.point),r);c=Math.max(c,n),o=Math.min(o,n)}));for(const e of n){const n=Z(e,t);(null==n?void 0:n.intersects)&&n.intersectionPoints&&n.intersectionPoints.forEach((e=>{s.some((t=>u.vec3.len(u.vec3.sub(t,e))<l.EPSILON))||s.push(e)}))}return i=o*c<=0?Math.max(Math.abs(o),Math.abs(c)):Math.abs(c)<Math.abs(o)?Math.abs(c):Math.abs(o),{intersects:s.length>0,intersectionPoints:s.length>0?s:void 0,penetrationDepth:i}},t.cuboidIntersectsPolygon=B,t.cuboidIntersectsMesh=function(e,t){const n=M(t),s=[];for(const t of n){const n=B(e,t);if(n&&n.intersects){if(!n.intersectionPoints)return{intersects:!0};n.intersectionPoints.forEach((e=>{s.some((t=>(0,v.vectorsAlmostEqual)(t,e)))||s.push(e)}))}}return{intersects:s.length>0,intersectionPoints:s.length>0?s:void 0}},t.polygonIntersectsPolygon=R,t.polygonIntersectsPlane=Z,t.polygonIntersectsMesh=function(e,t){if(!x(e))return null;const n=M(t),s=[];for(const t of n){const n=R(e,t);if(n&&n.intersects){if(!n.intersectionPoints)return{intersects:!0};n.intersectionPoints.forEach((e=>{s.some((t=>(0,v.vectorsAlmostEqual)(t,e)))||s.push(e)}))}}return{intersects:s.length>0,intersectionPoints:s.length>0?s:void 0}},t.meshIntersectsMesh=function(e,t){const n=M(e),s=M(t),r=[];for(const e of n)for(const t of s){const n=R(e,t);n&&n.intersects&&n.intersectionPoints&&n.intersectionPoints.forEach((e=>{r.some((t=>u.vec3.len(u.vec3.sub(t,e))<l.EPSILON))||r.push(e)}))}return{intersects:r.length>0,intersectionPoints:r.length>0?r:void 0}},t.meshIntersectsPlane=T;const a=n(395),u=n(430),v=n(955),l=c(n(388)),d=n(962);function h(e,t=1){return{start:e.origin,end:u.vec3.add(e.origin,u.vec3.mul(e.direction,t))}}function f(e){return void 0!==e.rotation&&!(0,v.vectorAlmostZero)(e.rotation)}function m(e){const{position:t,size:n,rotation:s=(0,u.vec3)()}=e,r=u.vec3.div(n,2);let i=u.vec3.fromComponents(u.vec3.swiz(r,"XYz")),c=u.vec3.fromComponents(u.vec3.swiz(r,"xYz")),o=u.vec3.fromComponents(u.vec3.swiz(r,"xyz")),a=u.vec3.fromComponents(u.vec3.swiz(r,"Xyz")),v=u.vec3.fromComponents(u.vec3.swiz(r,"XYZ")),l=u.vec3.fromComponents(u.vec3.swiz(r,"xYZ")),d=u.vec3.fromComponents(u.vec3.swiz(r,"xyZ")),h=u.vec3.fromComponents(u.vec3.swiz(r,"XyZ"));return f(e)&&(i=u.vec3.rota(i,s),c=u.vec3.rota(c,s),o=u.vec3.rota(o,s),a=u.vec3.rota(a,s),v=u.vec3.rota(v,s),l=u.vec3.rota(l,s),d=u.vec3.rota(d,s),h=u.vec3.rota(h,s)),[u.vec3.add(t,i),u.vec3.add(t,c),u.vec3.add(t,o),u.vec3.add(t,a),u.vec3.add(t,v),u.vec3.add(t,l),u.vec3.add(t,d),u.vec3.add(t,h)]}function p(e){const t=m(e);if(8!==t.length)throw new Error("Cuboid must have exactly 8 vertices");return[{vertices:[t[0],t[1],t[2]]},{vertices:[t[0],t[2],t[3]]},{vertices:[t[4],t[5],t[6]]},{vertices:[t[4],t[6],t[7]]},{vertices:[t[0],t[1],t[5]]},{vertices:[t[0],t[5],t[4]]},{vertices:[t[2],t[3],t[7]]},{vertices:[t[2],t[7],t[6]]},{vertices:[t[0],t[3],t[7]]},{vertices:[t[0],t[7],t[4]]},{vertices:[t[1],t[2],t[6]]},{vertices:[t[1],t[6],t[5]]}]}function y(e){const t=[];for(let n=0;n<e.length;n++){const s=e[n],r=(0,a.at)(e,n+1);t.push({start:s,end:r})}return t}function x(e){return 3===e.vertices.length}function b(e){return x(e)?u.vec3.div(u.vec3.add(e.vertices[0],u.vec3.add(e.vertices[1],e.vertices[2])),3):null}function M(e){if(e.indices.length%3!=0)throw new Error("Mesh indices must be a multiple of 3 to form triangles");const t=[];for(let n=0;n<e.indices.length;n+=3){const s=e.indices.slice(n,n+3);if(3!==s.length)throw new Error("Mesh indices must form triangles");const r=s.map((t=>e.vertices[t]));t.push({vertices:r})}return t}function z(e,t){const n=u.vec3.sub(t.end,t.start),s=u.vec3.nor(n),r=u.vec3.sub(e,t.start),i=u.vec3.dot(r,s),c=u.vec3.len(n),o=Math.max(0,Math.min(c,i)),a=u.vec3.add(t.start,u.vec3.mul(s,o)),v=u.vec3.len(u.vec3.sub(e,a));return{intersects:v<l.EPSILON,closestPoint:a,distance:v}}function P(e,t){const{position:n,size:s,rotation:r=(0,u.vec3)()}=t,i=u.vec3.div(s,2);let c=u.vec3.sub(e,n);f(t)&&(c=u.vec3.rota(c,u.vec3.mul(r,-1)));const o=Math.max(Math.abs(c.x)-i.x,0),v=Math.max(Math.abs(c.y)-i.y,0),l=Math.max(Math.abs(c.z)-i.z,0);let d=(0,u.vec3)((0,a.clamp)(c.x,-i.x,i.x),(0,a.clamp)(c.y,-i.y,i.y),(0,a.clamp)(c.z,-i.z,i.z));f(t)&&(d=u.vec3.rota(d,r)),d=u.vec3.add(d,n);const h=0===o&&0===v&&0===l;return{intersects:h,closestPoint:d,distance:h?-Math.min(i.x-Math.abs(c.x),i.y-Math.abs(c.y),i.z-Math.abs(c.z)):Math.sqrt(o*o+v*v+l*l)}}function g(e,t){if(!x(t))return null;const[n,s,r]=t.vertices,i=u.vec3.sub(s,n),c=u.vec3.sub(r,n),o=u.vec3.nor(u.vec3.cross(i,c)),a=-u.vec3.dot(o,n),v=u.vec3.dot(o,e)+a,d=u.vec3.sub(e,u.vec3.mul(o,v)),h=u.vec3.len(u.vec3.cross(i,c))/2,f=u.vec3.sub(r,s),m=u.vec3.sub(d,n),p=u.vec3.sub(d,s),y=u.vec3.sub(d,r),b=u.vec3.len(u.vec3.cross(f,p))/(2*h),M=u.vec3.len(u.vec3.cross(c,y))/(2*h),P=u.vec3.len(u.vec3.cross(i,m))/(2*h),g=b+M+P;let I,O;if(b>=-l.EPSILON&&M>=-l.EPSILON&&P>=-l.EPSILON&&Math.abs(g-1)<l.EPSILON)I=d,O=Math.abs(v);else{const t=z(e,{start:n,end:s}),i=z(e,{start:s,end:r}),c=z(e,{start:r,end:n}),o=Math.min(t.distance,i.distance,c.distance);I=o===t.distance?t.closestPoint:o===i.distance?i.closestPoint:c.closestPoint,O=o}return{intersects:O<l.EPSILON,closestPoint:I,distance:O}}function I(e,t){let n=u.vec3.sub(t.end,t.start);const s=u.vec3.len(n);if(s<l.EPSILON)return{intersects:!1};const r=u.vec3.nor(e.direction);n=u.vec3.div(n,s);const i=u.vec3.sub(t.start,e.origin),c=u.vec3.cross(r,n),o=u.vec3.dot(c,c);if(o<l.EPSILON){const e=u.vec3.cross(i,r);if(u.vec3.len(e)<l.EPSILON){const e=u.vec3.dot(i,n);if(e>=0&&e<=s)return{intersects:!0,intersectionPoint:u.vec3.add(t.start,u.vec3.mul(n,e))}}return{intersects:!1}}const a=u.vec3.dot(i,u.vec3.cross(n,c))/o,v=u.vec3.dot(i,u.vec3.cross(r,c))/o;if(a>=0&&v>=0&&v<=s){const s=u.vec3.add(e.origin,u.vec3.mul(r,a)),i=u.vec3.add(t.start,u.vec3.mul(n,v));if(u.vec3.len(u.vec3.sub(s,i))<l.EPSILON)return{intersects:!0,intersectionPoint:u.vec3.add(s,u.vec3.mul(u.vec3.sub(i,s),.5))}}return{intersects:!1}}function O(e,t){const n=u.vec3.nor(e.direction),s=u.vec3.nor(t.normal),r=u.vec3.dot(n,s);if(Math.abs(r)<l.EPSILON){const n=u.vec3.dot(u.vec3.sub(e.origin,t.point),s);return Math.abs(n)<l.EPSILON?{intersects:!0}:{intersects:!1}}const i=u.vec3.dot(u.vec3.sub(t.point,e.origin),s)/r;return i<0?{intersects:!1}:{intersects:!0,intersectionPoint:u.vec3.add(e.origin,u.vec3.mul(n,i))}}function E(e,t){const n=u.vec3.nor(e.direction),{position:s,size:r,rotation:i=(0,u.vec3)()}=t;let c=u.vec3.sub(e.origin,s),o=n;if(f(t)){const e=u.vec3.mul(i,-1);c=u.vec3.rota(c,e),o=u.vec3.rota(o,e)}const a=u.vec3.div(r,2),v=u.vec3.div(u.vec3.sub(u.vec3.mul(a,-1),c),o),l=u.vec3.div(u.vec3.sub(a,c),o),d=(0,u.vec3)(Math.min(v.x,l.x),Math.min(v.y,l.y),Math.min(v.z,l.z)),h=(0,u.vec3)(Math.max(v.x,l.x),Math.max(v.y,l.y),Math.max(v.z,l.z)),m=Math.max(d.x,d.y,d.z),p=Math.min(h.x,h.y,h.z);if(m>p||p<0)return{intersects:!1};const y=[];if(m>=0){let e=u.vec3.add(c,u.vec3.mul(o,m));f(t)&&(e=u.vec3.rota(e,i)),y.push(u.vec3.add(s,e))}if(p>m&&p>=0){let e=u.vec3.add(c,u.vec3.mul(o,p));f(t)&&(e=u.vec3.rota(e,i)),y.push(u.vec3.add(s,e))}return{intersects:y.length>0,intersectionPoints:y.length>0?y:void 0}}function S(e,t){if(!x(t))return null;const[n,s,r]=t.vertices,i=u.vec3.sub(s,n),c=u.vec3.sub(r,n),o=O(e,{point:n,normal:u.vec3.nor(u.vec3.cross(i,c))});if(!o.intersects||!o.intersectionPoint)return{intersects:!1};const a=g(o.intersectionPoint,t);return a&&a.intersects?{intersects:!0,intersectionPoint:o.intersectionPoint}:{intersects:!1}}function L(e,t){const n=u.vec3.sub(e.end,e.start),s=u.vec3.sub(t.end,t.start),r=u.vec3.len(n),i=u.vec3.len(s);if(r<l.EPSILON||i<l.EPSILON)return{intersects:!1};const c=u.vec3.div(n,r),o=u.vec3.div(s,i),v=u.vec3.sub(t.start,e.start),d=u.vec3.cross(c,o),h=u.vec3.dot(d,d);if(h<l.EPSILON){const t=u.vec3.cross(v,c);if(u.vec3.len(t)<l.EPSILON){const t=u.vec3.dot(v,c),n=t+u.vec3.dot(s,c),i=Math.min(t,n),o=Math.max(t,n);if(i<=r&&o>=0){const t=(0,a.clamp)(0,Math.max(0,i),r);return{intersects:!0,intersectionPoint:u.vec3.add(e.start,u.vec3.mul(c,t))}}}return{intersects:!1}}const f=u.vec3.dot(v,u.vec3.cross(s,d))/h,m=u.vec3.dot(v,u.vec3.cross(n,d))/h;if(f>=0&&f<=r&&m>=0&&m<=i){const n=u.vec3.add(e.start,u.vec3.mul(c,f)),s=u.vec3.add(t.start,u.vec3.mul(o,m));if(u.vec3.len(u.vec3.sub(n,s))<l.EPSILON)return{intersects:!0,intersectionPoint:u.vec3.add(n,u.vec3.mul(u.vec3.sub(s,n),.5))}}return{intersects:!1}}function N(e,t){const n=u.vec3.sub(e.end,e.start),s=u.vec3.len(n);if(s<l.EPSILON)return u.vec3.len(u.vec3.sub(e.start,t.position))<=t.radius?{intersects:!0,intersectionPoints:[e.start]}:{intersects:!1};const r=u.vec3.div(n,s),i=u.vec3.sub(t.position,e.start),c=u.vec3.dot(r,r),o=2*u.vec3.dot(r,u.vec3.mul(i,-1)),a=o*o-4*c*(u.vec3.dot(i,i)-t.radius*t.radius);if(a<-l.EPSILON)return{intersects:!1};if(Math.abs(a)<l.EPSILON){const t=-o/(2*c);return t>=0&&t<=s?{intersects:!0,intersectionPoints:[u.vec3.add(e.start,u.vec3.mul(r,t))]}:{intersects:!1}}const v=Math.sqrt(a),d=(-o-v)/(2*c),h=(-o+v)/(2*c),f=[];return d>=0&&d<=s&&f.push(u.vec3.add(e.start,u.vec3.mul(r,d))),h>=0&&h<=s&&f.push(u.vec3.add(e.start,u.vec3.mul(r,h))),{intersects:f.length>0,intersectionPoints:f.length>0?f:void 0}}function w(e,t){const n=u.vec3.sub(e.end,e.start),s=u.vec3.len(n);if(s<l.EPSILON)return{intersects:!1};const r=u.vec3.div(n,s),i=u.vec3.dot(r,t.normal);if(Math.abs(i)<l.EPSILON){const n=u.vec3.dot(u.vec3.sub(e.start,t.point),t.normal);return Math.abs(n)<l.EPSILON?{intersects:!0}:{intersects:!1}}const c=u.vec3.dot(u.vec3.sub(t.point,e.start),t.normal)/i;return c<0||c>s?{intersects:!1}:{intersects:!0,intersectionPoint:u.vec3.add(e.start,u.vec3.mul(r,c))}}function j(e,t){if(!x(t))return{intersects:!1};const[n,s,r]=t.vertices,i=u.vec3.sub(s,n),c=u.vec3.sub(r,n),o=w(e,{point:n,normal:u.vec3.nor(u.vec3.cross(i,c))});if(!o.intersects||!o.intersectionPoint)return{intersects:!1};const a=g(o.intersectionPoint,t);return a&&a.intersects?{intersects:!0,intersectionPoint:o.intersectionPoint}:{intersects:!1}}function A(e,t){const n=u.vec3.nor(t.normal),s=u.vec3.dot(u.vec3.sub(e.position,t.point),n);if(Math.abs(s)>e.radius)return{intersects:!1};const r=e.radius-Math.abs(s);return{intersects:!0,intersectionPoint:u.vec3.sub(e.position,u.vec3.mul(n,s)),penetrationDepth:r,intersectionRadius:Math.sqrt(e.radius*e.radius-s*s)}}function _(e,t){if(!x(t))return null;const[n,s,r]=t.vertices,i=u.vec3.sub(s,n),c=u.vec3.sub(r,n),o=u.vec3.nor(u.vec3.cross(i,c)),a=A(e,{point:n,normal:o});if(!a.intersects)return{intersects:!1};if(t.vertices.map((t=>u.vec3.len(u.vec3.sub(t,e.position)))).every((t=>t<=e.radius)))return{intersects:!0,intersectionPoint:a.intersectionPoint,penetrationDepth:e.radius};const v=[];[{start:n,end:s},{start:s,end:r},{start:r,end:n}].forEach((t=>{const n=N(t,e);n.intersects&&n.intersectionPoints&&n.intersectionPoints.forEach((e=>{z(e,t).intersects&&v.push(e)}))}));const l=g(e.position,t);if(l&&l.intersects){const t=u.vec3.len(u.vec3.sub(e.position,l.closestPoint));if(t<=e.radius)return{intersects:!0,intersectionPoint:l.closestPoint,penetrationDepth:e.radius-t,polygonIntersectionPoints:v.length>0?v:void 0}}if(v.length>0){const t=u.vec3.div(v.reduce(((e,t)=>u.vec3.add(e,t)),(0,u.vec3)()),v.length);return{intersects:!0,intersectionPoint:t,penetrationDepth:e.radius-u.vec3.len(u.vec3.sub(t,e.position)),polygonIntersectionPoints:v}}return{intersects:!1}}function k(e,t){const n=u.vec3.nor(e.normal),s=u.vec3.nor(t.normal),r=u.vec3.cross(n,s),i=u.vec3.dot(r,r);if(i<l.EPSILON){const s=u.vec3.dot(u.vec3.sub(t.point,e.point),n);return Math.abs(s)<l.EPSILON?{intersects:!0}:{intersects:!1}}const c=-u.vec3.dot(n,e.point),o=-u.vec3.dot(s,t.point),a=u.vec3.div(u.vec3.cross(u.vec3.sub(u.vec3.mul(n,o),u.vec3.mul(s,c)),r),i);return{intersects:!0,intersectionLine:{start:a,end:u.vec3.add(a,r)}}}function C(e){const t=Math.cos(e.x),n=Math.cos(e.y),s=Math.cos(e.z),r=Math.sin(e.x),i=Math.sin(e.y),c=Math.sin(e.z);return[(0,u.vec3)(n*s,n*c,-i),(0,u.vec3)(r*i*s-t*c,r*i*c+t*s,r*n),(0,u.vec3)(t*i*s+r*c,t*i*c-r*s,t*n)]}function q(e){return e||[(0,u.vec3)(1,0,0),(0,u.vec3)(0,1,0),(0,u.vec3)(0,0,1)]}function V(e,t){const n=[];for(const s of e)for(const e of t)n.push(u.vec3.cross(s,e));return n}function $(e,t,n){let s=0;return s=t?Math.abs(u.vec3.dot(u.vec3.mul(t[0],e.x),n))+Math.abs(u.vec3.dot(u.vec3.mul(t[1],e.y),n))+Math.abs(u.vec3.dot(u.vec3.mul(t[2],e.z),n)):Math.abs(e.x*n.x)+Math.abs(e.y*n.y)+Math.abs(e.z*n.z),s}function D(e,t){const n=m(e);let s=-1/0,r=n[0];for(const e of n){const n=u.vec3.dot(e,t);n>s&&(s=n,r=e)}return r}function B(e,t){if(!x(t))return null;const n=t.vertices.map((t=>P(t,e)));if(n.every((e=>e.intersects)))return{intersects:!0};const s=m(e),r=s.map((e=>g(e,t)));if(r.some((e=>null==e?void 0:e.intersects)))return{intersects:!0};const i=y(s),c=[];for(const e of i){const n=j(e,t);n&&n.intersects&&n.intersectionPoint&&(c.some((e=>(0,v.vectorsAlmostEqual)(e,n.intersectionPoint)))||c.push(n.intersectionPoint))}const o=y(t.vertices),a=p(e);for(const e of o)for(const t of a){const n=j(e,t);n&&n.intersects&&n.intersectionPoint&&(c.some((e=>(0,v.vectorsAlmostEqual)(e,n.intersectionPoint)))||c.push(n.intersectionPoint))}return{intersects:c.length>0||n.some((e=>e.intersects))||r.some((e=>null==e?void 0:e.intersects)),intersectionPoints:c.length>0?c:void 0}}function R(e,t){if(!x(e)||!x(t))return null;const n=k({point:e.vertices[0],normal:u.vec3.nor(u.vec3.cross(u.vec3.sub(e.vertices[1],e.vertices[0]),u.vec3.sub(e.vertices[2],e.vertices[0])))},{point:t.vertices[0],normal:u.vec3.nor(u.vec3.cross(u.vec3.sub(t.vertices[1],t.vertices[0]),u.vec3.sub(t.vertices[2],t.vertices[0])))});if(!n.intersects)return{intersects:!1};if(!n.intersectionLine){for(const n of e.vertices){const e=g(n,t);if(null==e?void 0:e.intersects)return{intersects:!0}}for(const n of t.vertices){const t=g(n,e);if(null==t?void 0:t.intersects)return{intersects:!0}}return{intersects:!1}}const s=y(e.vertices),r=y(t.vertices),i=[];for(const e of s)for(const t of r){const n=L(e,t);if(n.intersects&&n.intersectionPoint){const s=z(n.intersectionPoint,e),r=z(n.intersectionPoint,t);s.intersects&&r.intersects&&(i.some((e=>u.vec3.len(u.vec3.sub(e,n.intersectionPoint))<l.EPSILON))||i.push(n.intersectionPoint))}}return{intersects:i.length>0,intersectionPoints:i.length>0?i:void 0}}function Z(e,t){if(!x(e))return null;const n=y(e.vertices),s=[];let r=!1;for(const e of n){const n=w(e,t);if(n.intersects){if(!n.intersectionPoint){r=!0;break}s.push(n.intersectionPoint)}}if(r)return{intersects:!0};const i=s.filter(((e,t)=>!s.some(((n,s)=>s<t&&u.vec3.len(u.vec3.sub(n,e))<l.EPSILON))));return{intersects:i.length>0,intersectionPoints:i.length>0?i:void 0}}function T(e,t){const n=M(e),s=[];let r=-1/0,i=1/0;const c=u.vec3.nor(t.normal);e.vertices.forEach((e=>{const n=u.vec3.dot(u.vec3.sub(e,t.point),c);r=Math.max(r,n),i=Math.min(i,n)}));let o,a=!1;for(const e of n){const n=Z(e,t);(null==n?void 0:n.intersects)&&(a=!0,n.intersectionPoints&&n.intersectionPoints.forEach((e=>{s.some((t=>u.vec3.len(u.vec3.sub(t,e))<l.EPSILON))||s.push(e)})))}return o=i*r<=0?Math.max(Math.abs(i),Math.abs(r)):Math.abs(r)<Math.abs(i)?Math.abs(r):Math.abs(i),{intersects:a,intersectionPoints:s.length>0?s:void 0,penetrationDepth:o}}o(n(962),t)},962:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isPoint=r,t.isRay=function(e){return e&&"object"==typeof e&&"origin"in e&&r(e.origin)&&"direction"in e&&(0,s.isVec3)(e.direction)},t.isLine=function(e){return e&&"object"==typeof e&&"start"in e&&r(e.start)&&"end"in e&&r(e.end)},t.isSphere=function(e){return e&&"object"==typeof e&&"position"in e&&r(e.position)&&"radius"in e&&"number"==typeof e.radius},t.isAABB=function(e){return e&&"object"==typeof e&&"position"in e&&r(e.position)&&"size"in e&&(0,s.isVec3)(e.size)},t.isCuboid=function(e){return e&&"object"==typeof e&&"position"in e&&r(e.position)&&"size"in e&&(0,s.isVec3)(e.size)&&(!("rotation"in e)||(0,s.isVec3)(e.rotation))},t.isPlane=function(e){return e&&"object"==typeof e&&"point"in e&&r(e.point)&&"normal"in e&&(0,s.isVec3)(e.normal)},t.isPolygon=function(e){return e&&"object"==typeof e&&"vertices"in e&&Array.isArray(e.vertices)&&3===e.vertices.length&&e.vertices.every(r)&&!("indices"in e)},t.isMesh=function(e){return e&&"object"==typeof e&&"vertices"in e&&Array.isArray(e.vertices)&&e.vertices.every(r)&&"indices"in e&&Array.isArray(e.indices)&&e.indices.every((e=>"number"==typeof e))};const s=n(197);function r(e){return(0,s.isVec3)(e)}},388:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EPSILON=void 0,t.EPSILON=1e-6},955:function(e,t,n){"use strict";var s,r=this&&this.__createBinding||(Object.create?function(e,t,n,s){void 0===s&&(s=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,s,r)}:function(e,t,n,s){void 0===s&&(s=n),e[s]=t[n]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),c=this&&this.__importStar||(s=function(e){return s=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n);return t},s(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n=s(e),c=0;c<n.length;c++)"default"!==n[c]&&r(t,e,n[c]);return i(t,e),t}),o=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),t.vectorAlmostZero=function(e){return(0,u.isVec3)(e)?Math.abs(e.x)<a.EPSILON&&Math.abs(e.y)<a.EPSILON&&Math.abs(e.z)<a.EPSILON:!!(0,u.isVec2)(e)&&Math.abs(e.x)<a.EPSILON&&Math.abs(e.y)<a.EPSILON},t.vectorsAlmostEqual=function(e,t){return(0,u.isVec3)(e)&&(0,u.isVec3)(t)?Math.abs(e.x-t.x)<a.EPSILON&&Math.abs(e.y-t.y)<a.EPSILON&&Math.abs(e.z-t.z)<a.EPSILON:!(!(0,u.isVec2)(e)||!(0,u.isVec2)(t))&&Math.abs(e.x-t.x)<a.EPSILON&&Math.abs(e.y-t.y)<a.EPSILON},t.valueInInterval=function(e,t){const{min:n,minInclusive:s=!0,max:r,maxInclusive:i=!0}=t;return(s?e>=n:e>n)&&(i?e<=r:e<r)},t.intervalsOverlap=v,t.overlapInterval=function(e,t){return v(e,t)?{min:Math.max(e.min,t.min),max:Math.min(e.max,t.max)}:null};const a=c(n(388)),u=n(197);function v(e,t){return Math.max(e.min,t.min)<=Math.min(e.max,t.max)}o(n(197),t)},197:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isVec2=function(e){return e&&"object"==typeof e&&"x"in e&&"number"==typeof e.x&&"y"in e&&"number"==typeof e.y&&!("z"in e)},t.isVec3=function(e){return e&&"object"==typeof e&&"x"in e&&"number"==typeof e.x&&"y"in e&&"number"==typeof e.y&&"z"in e&&"number"==typeof e.z}}},t={},function n(s){var r=t[s];if(void 0!==r)return r.exports;var i=t[s]={exports:{}};return e[s].call(i.exports,i,i.exports,n),i.exports}(82);var e,t}));